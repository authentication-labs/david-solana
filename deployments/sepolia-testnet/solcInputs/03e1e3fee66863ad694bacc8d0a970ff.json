{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IGetCCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetCCIPAdmin {\n  /// @notice Returns the admin of the token.\n  /// @dev This method is named to never conflict with existing methods.\n  function getCCIPAdmin() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwner {\n  /// @notice Returns the owner of the contract.\n  /// @dev This method is named to match with the OpenZeppelin Ownable contract.\n  function owner() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouter {\n  error OnlyOffRamp();\n\n  /// @notice Route the message to its intended receiver contract.\n  /// @param message Client.Any2EVMMessage struct.\n  /// @param gasForCallExactCheck of params for exec\n  /// @param gasLimit set of params for exec\n  /// @param receiver set of params for exec\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\n  /// the contract is called. If not, only tokens are transferred.\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\n\n  /// @notice Returns the configured onramp for a specific destination chain.\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\n  /// @return onRampAddress The address of the onRamp.\n  function getOnRamp(uint64 destChainSelector) external view returns (address onRampAddress);\n\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\n  /// @param sourceChainSelector The source chain selector to check.\n  /// @param offRamp The address of the offRamp to check.\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param destChainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 destChainSelector) external view returns (bool supported);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV2\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to other messages from the same sender.\n  /// This value's default varies by chain. On some chains, a particular value is enforced, meaning if the expected value\n  /// is not set, the message request will revert.\n  struct EVMExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  function _argsToBytes(EVMExtraArgsV2 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {MerkleMultiProof} from \"../libraries/MerkleMultiProof.sol\";\nimport {Client} from \"./Client.sol\";\n\n// Library for CCIP internal definitions common to multiple contracts.\nlibrary Internal {\n  error InvalidEVMAddress(bytes encodedAddress);\n\n  /// @dev The minimum amount of gas to perform the call with exact gas.\n  /// We include this in the offramp so that we can redeploy to adjust it\n  /// should a hardfork change the gas costs of relevant opcodes in callWithExactGas.\n  uint16 internal constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  // @dev We limit return data to a selector plus 4 words. This is to avoid\n  // malicious contracts from returning large amounts of data and causing\n  // repeated out-of-gas scenarios.\n  uint16 internal constant MAX_RET_BYTES = 4 + 4 * 32;\n  /// @dev The expected number of bytes returned by the balanceOf function.\n  uint256 internal constant MAX_BALANCE_OF_RET_BYTES = 32;\n\n  /// @notice A collection of token price and gas price updates.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct PriceUpdates {\n    TokenPriceUpdate[] tokenPriceUpdates;\n    GasPriceUpdate[] gasPriceUpdates;\n  }\n\n  /// @notice Token price in USD.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct TokenPriceUpdate {\n    address sourceToken; // Source token\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\n  }\n\n  /// @notice Gas price for a given chain in USD, its value may contain tightly packed fields.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct GasPriceUpdate {\n    uint64 destChainSelector; // Destination chain selector\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas\n  }\n\n  /// @notice A timestamped uint224 value that can contain several tightly packed fields.\n  struct TimestampedPackedUint224 {\n    uint224 value; // ───────╮ Value in uint224, packed.\n    uint32 timestamp; // ────╯ Timestamp of the most recent price update.\n  }\n\n  /// @dev Gas price is stored in 112-bit unsigned int. uint224 can pack 2 prices.\n  /// When packing L1 and L2 gas prices, L1 gas price is left-shifted to the higher-order bits.\n  /// Using uint8 type, which cannot be higher than other bit shift operands, to avoid shift operand type warning.\n  uint8 public constant GAS_PRICE_BITS = 112;\n\n  struct PoolUpdate {\n    address token; // The IERC20 token address\n    address pool; // The token pool address\n  }\n\n  struct SourceTokenData {\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    bytes sourcePoolAddress;\n    // The address of the destination token, abi encoded in the case of EVM chains\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\n  }\n\n  /// @notice Report that is submitted by the execution DON at the execution phase. (including chain selector data)\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct ExecutionReportSingleChain {\n    uint64 sourceChainSelector; // Source chain selector for which the report is submitted\n    Any2EVMRampMessage[] messages;\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token\n    bytes[][] offchainTokenData;\n    bytes32[] proofs;\n    uint256 proofFlagBits;\n  }\n\n  /// @notice Report that is submitted by the execution DON at the execution phase.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct ExecutionReport {\n    EVM2EVMMessage[] messages;\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token\n    bytes[][] offchainTokenData;\n    bytes32[] proofs;\n    uint256 proofFlagBits;\n  }\n\n  /// @notice The cross chain message that gets committed to EVM chains.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVM2EVMMessage {\n    uint64 sourceChainSelector; // ────────╮ the chain selector of the source chain, note: not chainId\n    address sender; // ────────────────────╯ sender address on the source chain\n    address receiver; // ──────────────────╮ receiver address on the destination chain\n    uint64 sequenceNumber; // ─────────────╯ sequence number, not unique across lanes\n    uint256 gasLimit; //                     user supplied maximum gas amount available for dest chain execution\n    bool strict; // ───────────────────────╮ DEPRECATED\n    uint64 nonce; //                       │ nonce for this lane for this sender, not unique across senders/lanes\n    address feeToken; // ──────────────────╯ fee token\n    uint256 feeTokenAmount; //               fee token amount\n    bytes data; //                           arbitrary data payload supplied by the message sender\n    Client.EVMTokenAmount[] tokenAmounts; // array of tokens and amounts to transfer\n    bytes[] sourceTokenData; //              array of token data, one per token\n    bytes32 messageId; //                    a hash of the message data\n  }\n\n  /// @dev EVM2EVMMessage struct has 13 fields, including 3 variable arrays.\n  /// Each variable array takes 1 more slot to store its length.\n  /// When abi encoded, excluding array contents,\n  /// EVM2EVMMessage takes up a fixed number of 16 lots, 32 bytes each.\n  /// For structs that contain arrays, 1 more slot is added to the front, reaching a total of 17.\n  uint256 public constant MESSAGE_FIXED_BYTES = 32 * 17;\n\n  /// @dev Each token transfer adds 1 EVMTokenAmount and 3 bytes at 3 slots each and one slot for the destGasAmount.\n  /// When abi encoded, each EVMTokenAmount takes 2 slots, each bytes takes 1 slot for length, one slot of data and one\n  /// slot for the offset. This results in effectively 3*3 slots per SourceTokenData.\n  /// 0x20\n  /// destGasAmount\n  /// sourcePoolAddress_offset\n  /// destTokenAddress_offset\n  /// extraData_offset\n  /// sourcePoolAddress_length\n  /// sourcePoolAddress_content // assume 1 slot\n  /// destTokenAddress_length\n  /// destTokenAddress_content // assume 1 slot\n  /// extraData_length // contents billed separately\n  uint256 public constant MESSAGE_FIXED_BYTES_PER_TOKEN = 32 * ((1 + 3 * 3) + 2);\n\n  /// @dev Any2EVMRampMessage struct has 10 fields, including 3 variable unnested arrays (data, receiver and tokenAmounts).\n  /// Each variable array takes 1 more slot to store its length.\n  /// When abi encoded, excluding array contents,\n  /// Any2EVMMessage takes up a fixed number of 13 slots, 32 bytes each.\n  /// For structs that contain arrays, 1 more slot is added to the front, reaching a total of 14.\n  /// The fixed bytes does not cover struct data (this is represented by ANY_2_EVM_MESSAGE_FIXED_BYTES_PER_TOKEN)\n  uint256 public constant ANY_2_EVM_MESSAGE_FIXED_BYTES = 32 * 14;\n\n  /// @dev Each token transfer adds 1 RampTokenAmount\n  /// RampTokenAmount has 5 fields, 2 of which are bytes type, 1 Address, 1 uint256 and 1 uint32.\n  /// Each bytes type takes 1 slot for length, 1 slot for data and 1 slot for the offset.\n  /// address\n  /// uint256 amount takes 1 slot.\n  /// uint32 destGasAmount takes 1 slot.\n  uint256 public constant ANY_2_EVM_MESSAGE_FIXED_BYTES_PER_TOKEN = 32 * ((2 * 3) + 3);\n\n  bytes32 internal constant EVM_2_EVM_MESSAGE_HASH = keccak256(\"EVM2EVMMessageHashV2\");\n\n  /// @dev Used to hash messages for single-lane ramps.\n  /// OnRamp hash(EVM2EVMMessage) = OffRamp hash(EVM2EVMMessage)\n  /// The EVM2EVMMessage's messageId is expected to be the output of this hash function\n  /// @param original Message to hash\n  /// @param metadataHash Immutable metadata hash representing a lane with a fixed OnRamp\n  /// @return hashedMessage hashed message as a keccak256\n  function _hash(EVM2EVMMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\n    return keccak256(\n      abi.encode(\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\n        metadataHash,\n        keccak256(\n          abi.encode(\n            original.sender,\n            original.receiver,\n            original.sequenceNumber,\n            original.gasLimit,\n            original.strict,\n            original.nonce,\n            original.feeToken,\n            original.feeTokenAmount\n          )\n        ),\n        keccak256(original.data),\n        keccak256(abi.encode(original.tokenAmounts)),\n        keccak256(abi.encode(original.sourceTokenData))\n      )\n    );\n  }\n\n  bytes32 internal constant ANY_2_EVM_MESSAGE_HASH = keccak256(\"Any2EVMMessageHashV1\");\n  bytes32 internal constant EVM_2_ANY_MESSAGE_HASH = keccak256(\"EVM2AnyMessageHashV1\");\n\n  /// @dev Used to hash messages for multi-lane family-agnostic OffRamps.\n  /// OnRamp hash(EVM2AnyMessage) != Any2EVMRampMessage.messageId\n  /// OnRamp hash(EVM2AnyMessage) != OffRamp hash(Any2EVMRampMessage)\n  /// @param original OffRamp message to hash\n  /// @param metadataHash Hash preimage to ensure global uniqueness\n  /// @return hashedMessage hashed message as a keccak256\n  function _hash(Any2EVMRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\n    return keccak256(\n      abi.encode(\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\n        metadataHash,\n        keccak256(\n          abi.encode(\n            original.header.messageId,\n            original.receiver,\n            original.header.sequenceNumber,\n            original.gasLimit,\n            original.header.nonce\n          )\n        ),\n        keccak256(original.sender),\n        keccak256(original.data),\n        keccak256(abi.encode(original.tokenAmounts))\n      )\n    );\n  }\n\n  function _hash(EVM2AnyRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\n    return keccak256(\n      abi.encode(\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\n        metadataHash,\n        keccak256(\n          abi.encode(\n            original.sender,\n            original.header.sequenceNumber,\n            original.header.nonce,\n            original.feeToken,\n            original.feeTokenAmount\n          )\n        ),\n        keccak256(original.receiver),\n        keccak256(original.data),\n        keccak256(abi.encode(original.tokenAmounts)),\n        keccak256(original.extraArgs)\n      )\n    );\n  }\n\n  /// @dev We disallow the first 1024 addresses to avoid calling into a range known for hosting precompiles. Calling\n  /// into precompiles probably won't cause any issues, but to be safe we can disallow this range. It is extremely\n  /// unlikely that anyone would ever be able to generate an address in this range. There is no official range of\n  /// precompiles, but EIP-7587 proposes to reserve the range 0x100 to 0x1ff. Our range is more conservative, even\n  /// though it might not be exhaustive for all chains, which is OK. We also disallow the zero address, which is a\n  /// common practice.\n  uint256 public constant PRECOMPILE_SPACE = 1024;\n\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the\n  /// address is within the EVM address space. If it isn't it will revert with an InvalidEVMAddress error, which\n  /// we can catch and handle more gracefully than a revert from abi.decode.\n  /// @return The address if it is valid, the function will revert otherwise.\n  function _validateEVMAddress(bytes memory encodedAddress) internal pure returns (address) {\n    if (encodedAddress.length != 32) revert InvalidEVMAddress(encodedAddress);\n    uint256 encodedAddressUint = abi.decode(encodedAddress, (uint256));\n    if (encodedAddressUint > type(uint160).max || encodedAddressUint < PRECOMPILE_SPACE) {\n      revert InvalidEVMAddress(encodedAddress);\n    }\n    return address(uint160(encodedAddressUint));\n  }\n\n  /// @notice Enum listing the possible message execution states within\n  /// the offRamp contract.\n  /// UNTOUCHED never executed\n  /// IN_PROGRESS currently being executed, used a replay protection\n  /// SUCCESS successfully executed. End state\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\n  /// @dev RMN depends on this enum, if changing, please notify the RMN maintainers.\n  enum MessageExecutionState {\n    UNTOUCHED,\n    IN_PROGRESS,\n    SUCCESS,\n    FAILURE\n  }\n\n  /// @notice CCIP OCR plugin type, used to separate execution & commit transmissions and configs\n  enum OCRPluginType {\n    Commit,\n    Execution\n  }\n\n  /// @notice Family-agnostic header for OnRamp & OffRamp messages.\n  /// The messageId is not expected to match hash(message), since it may originate from another ramp family\n  struct RampMessageHeader {\n    bytes32 messageId; // Unique identifier for the message, generated with the source chain's encoding scheme (i.e. not necessarily abi.encoded)\n    uint64 sourceChainSelector; // ──╮ the chain selector of the source chain, note: not chainId\n    uint64 destChainSelector; //     | the chain selector of the destination chain, note: not chainId\n    uint64 sequenceNumber; //        │ sequence number, not unique across lanes\n    uint64 nonce; // ────────────────╯ nonce for this lane for this sender, not unique across senders/lanes\n  }\n\n  struct EVM2AnyTokenTransfer {\n    // The source pool EVM address. This value is trusted as it was obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    address sourcePoolAddress;\n    // The EVM address of the destination token\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint256 amount; // Amount of tokens.\n    // Destination chain specific execution data encoded in bytes\n    // for an EVM destination, it consists of the amount of gas available for the releaseOrMint\n    // and transfer calls made by the offRamp\n    bytes destExecData;\n  }\n\n  struct Any2EVMTokenTransfer {\n    // The source pool EVM address encoded to bytes. This value is trusted as it is obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    bytes sourcePoolAddress;\n    address destTokenAddress; // ───╮ Address of destination token\n    uint32 destGasAmount; //────────╯ The amount of gas available for the releaseOrMint and transfer calls on the offRamp.\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint256 amount; // Amount of tokens.\n  }\n\n  /// @notice Family-agnostic message routed to an OffRamp\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage), hash(Any2EVMRampMessage) != messageId\n  /// due to encoding & parameter differences\n  struct Any2EVMRampMessage {\n    RampMessageHeader header; // Message header\n    bytes sender; // sender address on the source chain\n    bytes data; // arbitrary data payload supplied by the message sender\n    address receiver; // receiver address on the destination chain\n    uint256 gasLimit; // user supplied maximum gas amount available for dest chain execution\n    Any2EVMTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer\n  }\n\n  /// @notice Family-agnostic message emitted from the OnRamp\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage) due to encoding & parameter differences\n  /// messageId = hash(EVM2AnyRampMessage) using the source EVM chain's encoding format\n  struct EVM2AnyRampMessage {\n    RampMessageHeader header; // Message header\n    address sender; // sender address on the source chain\n    bytes data; // arbitrary data payload supplied by the message sender\n    bytes receiver; // receiver address on the destination chain\n    bytes extraArgs; // destination-chain specific extra args, such as the gasLimit for EVM chains\n    address feeToken; // fee token\n    uint256 feeTokenAmount; // fee token amount\n    uint256 feeValueJuels; // fee amount in Juels\n    EVM2AnyTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer\n  }\n\n  // bytes4(keccak256(\"CCIP ChainFamilySelector EVM\"))\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_EVM = 0x2812d52c;\n\n  /// @dev Struct to hold a merkle root and an interval for a source chain so that an array of these can be passed in the CommitReport.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  /// @dev ineffiecient struct packing intentionally chosen to maintain order of specificity. Not a storage struct so impact is minimal.\n  // solhint-disable-next-line gas-struct-packing\n  struct MerkleRoot {\n    uint64 sourceChainSelector; //     Remote source chain selector that the Merkle Root is scoped to\n    bytes onRampAddress; //            Generic onramp address, to support arbitrary sources; for EVM, use abi.encode\n    uint64 minSeqNr; // ─────────────╮ Minimum sequence number, inclusive\n    uint64 maxSeqNr; // ─────────────╯ Maximum sequence number, inclusive\n    bytes32 merkleRoot; //             Merkle root covering the interval & source chain messages\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/MerkleMultiProof.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nlibrary MerkleMultiProof {\n  /// @notice Leaf domain separator, should be used as the first 32 bytes of a leaf's preimage.\n  bytes32 internal constant LEAF_DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\n  /// @notice Internal domain separator, should be used as the first 32 bytes of an internal node's preiimage.\n  bytes32 internal constant INTERNAL_DOMAIN_SEPARATOR =\n    0x0000000000000000000000000000000000000000000000000000000000000001;\n\n  uint256 internal constant MAX_NUM_HASHES = 256;\n\n  error InvalidProof();\n  error LeavesCannotBeEmpty();\n\n  /// @notice Computes the root based on provided pre-hashed leaf nodes in\n  /// leaves, internal nodes in proofs, and using proofFlagBits' i-th bit to\n  /// determine if an element of proofs or one of the previously computed leafs\n  /// or internal nodes will be used for the i-th hash.\n  /// @param leaves Should be pre-hashed and the first 32 bytes of a leaf's\n  /// preimage should match LEAF_DOMAIN_SEPARATOR.\n  /// @param proofs The hashes to be used instead of a leaf hash when the proofFlagBits\n  ///  indicates a proof should be used.\n  /// @param proofFlagBits A single uint256 of which each bit indicates whether a leaf or\n  ///  a proof needs to be used in a hash operation.\n  /// @dev the maximum number of hash operations it set to 256. Any input that would require\n  ///  more than 256 hashes to get to a root will revert.\n  /// @dev For given input `leaves` = [a,b,c] `proofs` = [D] and `proofFlagBits` = 5\n  ///     totalHashes = 3 + 1 - 1 = 3\n  ///  ** round 1 **\n  ///    proofFlagBits = (5 >> 0) & 1 = true\n  ///    hashes[0] = hashPair(a, b)\n  ///    (leafPos, hashPos, proofPos) = (2, 0, 0);\n  ///\n  ///  ** round 2 **\n  ///    proofFlagBits = (5 >> 1) & 1 = false\n  ///    hashes[1] = hashPair(D, c)\n  ///    (leafPos, hashPos, proofPos) = (3, 0, 1);\n  ///\n  ///  ** round 3 **\n  ///    proofFlagBits = (5 >> 2) & 1 = true\n  ///    hashes[2] = hashPair(hashes[0], hashes[1])\n  ///    (leafPos, hashPos, proofPos) = (3, 2, 1);\n  ///\n  ///    i = 3 and no longer < totalHashes. The algorithm is done\n  ///    return hashes[totalHashes - 1] = hashes[2]; the last hash we computed.\n  // We mark this function as internal to force it to be inlined in contracts\n  // that use it, but semantically it is public.\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function merkleRoot(\n    bytes32[] memory leaves,\n    bytes32[] memory proofs,\n    uint256 proofFlagBits\n  ) internal pure returns (bytes32) {\n    unchecked {\n      uint256 leavesLen = leaves.length;\n      uint256 proofsLen = proofs.length;\n      if (leavesLen == 0) revert LeavesCannotBeEmpty();\n      if (!(leavesLen <= MAX_NUM_HASHES + 1 && proofsLen <= MAX_NUM_HASHES + 1)) revert InvalidProof();\n      uint256 totalHashes = leavesLen + proofsLen - 1;\n      if (!(totalHashes <= MAX_NUM_HASHES)) revert InvalidProof();\n      if (totalHashes == 0) {\n        return leaves[0];\n      }\n      bytes32[] memory hashes = new bytes32[](totalHashes);\n      (uint256 leafPos, uint256 hashPos, uint256 proofPos) = (0, 0, 0);\n\n      for (uint256 i = 0; i < totalHashes; ++i) {\n        // Checks if the bit flag signals the use of a supplied proof or a leaf/previous hash.\n        bytes32 a;\n        if (proofFlagBits & (1 << i) == (1 << i)) {\n          // Use a leaf or a previously computed hash.\n          if (leafPos < leavesLen) {\n            a = leaves[leafPos++];\n          } else {\n            a = hashes[hashPos++];\n          }\n        } else {\n          // Use a supplied proof.\n          a = proofs[proofPos++];\n        }\n\n        // The second part of the hashed pair is never a proof as hashing two proofs would result in a\n        // hash that can already be computed offchain.\n        bytes32 b;\n        if (leafPos < leavesLen) {\n          b = leaves[leafPos++];\n        } else {\n          b = hashes[hashPos++];\n        }\n\n        if (!(hashPos <= i)) revert InvalidProof();\n\n        hashes[i] = _hashPair(a, b);\n      }\n      if (!(hashPos == totalHashes - 1 && leafPos == leavesLen && proofPos == proofsLen)) revert InvalidProof();\n      // Return the last hash.\n      return hashes[totalHashes - 1];\n    }\n  }\n\n  /// @notice Hashes two bytes32 objects in their given order, prepended by the\n  /// INTERNAL_DOMAIN_SEPARATOR.\n  function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32 hash) {\n    return keccak256(abi.encode(INTERNAL_DOMAIN_SEPARATOR, left, right));\n  }\n\n  /// @notice Hashes two bytes32 objects. The order is taken into account,\n  /// using the lower value first.\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n    return a < b ? _hashInternalNode(a, b) : _hashInternalNode(b, a);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/test/mocks/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../../interfaces/IAny2EVMMessageReceiver.sol\";\nimport {IRouter} from \"../../interfaces/IRouter.sol\";\nimport {IRouterClient} from \"../../interfaces/IRouterClient.sol\";\n\nimport {CallWithExactGas} from \"../../../shared/call/CallWithExactGas.sol\";\nimport {Client} from \"../../libraries/Client.sol\";\nimport {Internal} from \"../../libraries/Internal.sol\";\n\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC165Checker} from\n  \"../../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165Checker.sol\";\n\ncontract MockCCIPRouter is IRouter, IRouterClient {\n  using SafeERC20 for IERC20;\n  using ERC165Checker for address;\n\n  error InvalidAddress(bytes encodedAddress);\n  error InvalidExtraArgsTag();\n  error ReceiverError(bytes err);\n\n  event MessageExecuted(bytes32 messageId, uint64 sourceChainSelector, address offRamp, bytes32 calldataHash);\n  event MsgExecuted(bool success, bytes retData, uint256 gasUsed);\n\n  uint16 public constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  uint32 public constant DEFAULT_GAS_LIMIT = 200_000;\n\n  uint256 internal s_mockFeeTokenAmount; //use setFee() to change to non-zero to test fees\n\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retData, uint256 gasUsed) {\n    return _routeMessage(message, gasForCallExactCheck, gasLimit, receiver);\n  }\n\n  function _routeMessage(\n    Client.Any2EVMMessage memory message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) internal returns (bool success, bytes memory retData, uint256 gasUsed) {\n    // There are three cases in which we skip calling the receiver:\n    // 1. If the message data is empty AND the gas limit is 0.\n    //          This indicates a message that only transfers tokens. It is valid to only send tokens to a contract\n    //          that supports the IAny2EVMMessageReceiver interface, but without this first check we would call the\n    //          receiver without any gas, which would revert the transaction.\n    // 2. If the receiver is not a contract.\n    // 3. If the receiver is a contract but it does not support the IAny2EVMMessageReceiver interface.\n    //\n    // The ordering of these checks is important, as the first check is the cheapest to execute.\n    if (\n      (message.data.length == 0 && gasLimit == 0) || receiver.code.length == 0\n        || !receiver.supportsInterface(type(IAny2EVMMessageReceiver).interfaceId)\n    ) {\n      return (true, \"\", 0);\n    }\n\n    bytes memory data = abi.encodeWithSelector(IAny2EVMMessageReceiver.ccipReceive.selector, message);\n\n    (success, retData, gasUsed) = CallWithExactGas._callWithExactGasSafeReturnData(\n      data, receiver, gasLimit, gasForCallExactCheck, Internal.MAX_RET_BYTES\n    );\n\n    // Event to assist testing, does not exist on real deployments\n    emit MsgExecuted(success, retData, gasUsed);\n\n    // Real router event\n    emit MessageExecuted(message.messageId, message.sourceChainSelector, msg.sender, keccak256(data));\n    return (success, retData, gasUsed);\n  }\n\n  /// @notice Sends the tx locally to the receiver instead of on the destination chain.\n  /// @dev Ignores destinationChainSelector\n  /// @dev Returns a mock message ID, which is not calculated from the message contents in the\n  /// same way as the real message ID.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32) {\n    if (message.receiver.length != 32) revert InvalidAddress(message.receiver);\n    uint256 decodedReceiver = abi.decode(message.receiver, (uint256));\n    // We want to disallow sending to address(0) and to precompiles, which exist on address(1) through address(9).\n    if (decodedReceiver > type(uint160).max || decodedReceiver < 10) revert InvalidAddress(message.receiver);\n\n    uint256 feeTokenAmount = getFee(destinationChainSelector, message);\n    if (message.feeToken == address(0)) {\n      if (msg.value < feeTokenAmount) revert InsufficientFeeTokenAmount();\n    } else {\n      if (msg.value > 0) revert InvalidMsgValue();\n      IERC20(message.feeToken).safeTransferFrom(msg.sender, address(this), feeTokenAmount);\n    }\n\n    address receiver = address(uint160(decodedReceiver));\n    uint256 gasLimit = _fromBytes(message.extraArgs).gasLimit;\n    bytes32 mockMsgId = keccak256(abi.encode(message));\n\n    Client.Any2EVMMessage memory executableMsg = Client.Any2EVMMessage({\n      messageId: mockMsgId,\n      sourceChainSelector: 16015286601757825753, // Sepolia\n      sender: abi.encode(msg.sender),\n      data: message.data,\n      destTokenAmounts: message.tokenAmounts\n    });\n\n    for (uint256 i = 0; i < message.tokenAmounts.length; ++i) {\n      IERC20(message.tokenAmounts[i].token).safeTransferFrom(msg.sender, receiver, message.tokenAmounts[i].amount);\n    }\n\n    (bool success, bytes memory retData,) = _routeMessage(executableMsg, GAS_FOR_CALL_EXACT_CHECK, gasLimit, receiver);\n\n    if (!success) revert ReceiverError(retData);\n\n    return mockMsgId;\n  }\n\n  function _fromBytes(bytes calldata extraArgs) internal pure returns (Client.EVMExtraArgsV1 memory) {\n    if (extraArgs.length == 0) {\n      return Client.EVMExtraArgsV1({gasLimit: DEFAULT_GAS_LIMIT});\n    }\n    if (bytes4(extraArgs) != Client.EVM_EXTRA_ARGS_V1_TAG) revert InvalidExtraArgsTag();\n    return abi.decode(extraArgs[4:], (Client.EVMExtraArgsV1));\n  }\n\n  /// @notice Always returns true to make sure this check can be performed on any chain.\n  function isChainSupported(uint64) external pure returns (bool supported) {\n    return true;\n  }\n\n  /// @notice Returns an empty array.\n  function getSupportedTokens(uint64) external pure returns (address[] memory tokens) {\n    return new address[](0);\n  }\n\n  /// @notice Returns 0 as the fee is not supported in this mock contract.\n  function getFee(uint64, Client.EVM2AnyMessage memory) public view returns (uint256) {\n    return s_mockFeeTokenAmount;\n  }\n\n  /// @notice Sets the fees returned by getFee but is only checked when using native fee tokens\n  function setFee(uint256 feeAmount) external {\n    s_mockFeeTokenAmount = feeAmount;\n  }\n\n  /// @notice Always returns address(1234567890)\n  function getOnRamp(uint64 /* destChainSelector */ ) external pure returns (address onRampAddress) {\n    return address(1234567890);\n  }\n\n  /// @notice Always returns true\n  function isOffRamp(uint64, /* sourceChainSelector */ address /* offRamp */ ) external pure returns (bool) {\n    return true;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"./ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/call/CallWithExactGas.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This library contains various callWithExactGas functions. All of them are\n/// safe from gas bomb attacks.\n/// @dev There is code duplication in this library. This is done to not leave the assembly\n/// the blocks.\nlibrary CallWithExactGas {\n  error NoContract();\n  error NoGasForCallExactCheck();\n  error NotEnoughGasForCall();\n\n  bytes4 internal constant NO_CONTRACT_SIG = 0x0c3b563c;\n  bytes4 internal constant NO_GAS_FOR_CALL_EXACT_CHECK_SIG = 0xafa32a2c;\n  bytes4 internal constant NOT_ENOUGH_GAS_FOR_CALL_SIG = 0x37c3be29;\n\n  /// @notice calls target address with exactly gasAmount gas and payload as calldata.\n  /// Accounts for gasForCallExactCheck gas that will be used by this function. Will revert\n  /// if the target is not a contact. Will revert when there is not enough gas to call the\n  /// target with gasAmount gas.\n  /// @dev Ignores the return data, which makes it immune to gas bomb attacks.\n  /// @return success whether the call succeeded\n  function _callWithExactGas(\n    bytes memory payload,\n    address target,\n    uint256 gasLimit,\n    uint16 gasForCallExactCheck\n  ) internal returns (bool success) {\n    assembly {\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      // Note we do this check prior to measuring gas so gasForCallExactCheck (our \"cushion\")\n      // doesn't need to account for it.\n      if iszero(extcodesize(target)) {\n        mstore(0x0, NO_CONTRACT_SIG)\n        revert(0x0, 0x4)\n      }\n\n      let g := gas()\n      // Compute g -= gasForCallExactCheck and check for underflow\n      // The gas actually passed to the callee is _min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas. gasForCallExactCheck ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, gasForCallExactCheck) {\n        mstore(0x0, NO_GAS_FOR_CALL_EXACT_CHECK_SIG)\n        revert(0x0, 0x4)\n      }\n      g := sub(g, gasForCallExactCheck)\n      // if g - g//64 <= gasAmount, revert. We subtract g//64 because of EIP-150\n      if iszero(gt(sub(g, div(g, 64)), gasLimit)) {\n        mstore(0x0, NOT_ENOUGH_GAS_FOR_CALL_SIG)\n        revert(0x0, 0x4)\n      }\n\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasLimit, target, 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\n    }\n    return success;\n  }\n\n  /// @notice calls target address with exactly gasAmount gas and payload as calldata.\n  /// Account for gasForCallExactCheck gas that will be used by this function. Will revert\n  /// if the target is not a contact. Will revert when there is not enough gas to call the\n  /// target with gasAmount gas.\n  /// @dev Caps the return data length, which makes it immune to gas bomb attacks.\n  /// @dev Return data cap logic borrowed from\n  /// https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol.\n  /// @return success whether the call succeeded\n  /// @return retData the return data from the call, capped at maxReturnBytes bytes\n  /// @return gasUsed the gas used by the external call. Does not include the overhead of this function.\n  function _callWithExactGasSafeReturnData(\n    bytes memory payload,\n    address target,\n    uint256 gasLimit,\n    uint16 gasForCallExactCheck,\n    uint16 maxReturnBytes\n  ) internal returns (bool success, bytes memory retData, uint256 gasUsed) {\n    // allocate retData memory ahead of time\n    retData = new bytes(maxReturnBytes);\n\n    assembly {\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      // Note we do this check prior to measuring gas so gasForCallExactCheck (our \"cushion\")\n      // doesn't need to account for it.\n      if iszero(extcodesize(target)) {\n        mstore(0x0, NO_CONTRACT_SIG)\n        revert(0x0, 0x4)\n      }\n\n      let g := gas()\n      // Compute g -= gasForCallExactCheck and check for underflow\n      // The gas actually passed to the callee is _min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas. gasForCallExactCheck ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, gasForCallExactCheck) {\n        mstore(0x0, NO_GAS_FOR_CALL_EXACT_CHECK_SIG)\n        revert(0x0, 0x4)\n      }\n      g := sub(g, gasForCallExactCheck)\n      // if g - g//64 <= gasAmount, revert. We subtract g//64 because of EIP-150\n      if iszero(gt(sub(g, div(g, 64)), gasLimit)) {\n        mstore(0x0, NOT_ENOUGH_GAS_FOR_CALL_SIG)\n        revert(0x0, 0x4)\n      }\n\n      // We save the gas before the call so we can calculate how much gas the call used\n      let gasBeforeCall := gas()\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasLimit, target, 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\n      gasUsed := sub(gasBeforeCall, gas())\n\n      // limit our copy to maxReturnBytes bytes\n      let toCopy := returndatasize()\n      if gt(toCopy, maxReturnBytes) {\n        toCopy := maxReturnBytes\n      }\n      // Store the length of the copied bytes\n      mstore(retData, toCopy)\n      // copy the bytes from retData[0:_toCopy]\n      returndatacopy(add(retData, 0x20), 0x0, toCopy)\n    }\n    return (success, retData, gasUsed);\n  }\n\n  /// @notice Calls target address with exactly gasAmount gas and payload as calldata\n  /// or reverts if at least gasLimit gas is not available.\n  /// @dev Does not check if target is a contract. If it is not a contract, the low-level\n  /// call will still be made and it will succeed.\n  /// @dev Ignores the return data, which makes it immune to gas bomb attacks.\n  /// @return success whether the call succeeded\n  /// @return sufficientGas Whether there was enough gas to make the call\n  function _callWithExactGasEvenIfTargetIsNoContract(\n    bytes memory payload,\n    address target,\n    uint256 gasLimit,\n    uint16 gasForCallExactCheck\n  ) internal returns (bool success, bool sufficientGas) {\n    assembly {\n      let g := gas()\n      // Compute g -= CALL_WITH_EXACT_GAS_CUSHION and check for underflow. We\n      // need the cushion since the logic following the above call to gas also\n      // costs gas which we cannot account for exactly. So cushion is a\n      // conservative upper bound for the cost of this logic.\n      if iszero(lt(g, gasForCallExactCheck)) {\n        g := sub(g, gasForCallExactCheck)\n        // If g - g//64 <= gasAmount, we don't have enough gas. We subtract g//64 because of EIP-150.\n        if gt(sub(g, div(g, 64)), gasLimit) {\n          // Call and ignore success/return data. Note that we did not check\n          // whether a contract actually exists at the target address.\n          success := call(gasLimit, target, 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\n          sufficientGas := true\n        }\n      }\n    }\n    return (success, sufficientGas);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC677Receiver {\n  function onTokenTransfer(address sender, uint256 amount, bytes calldata data) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC20/IBurnMintERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBurnMintERC20 is IERC20 {\n  /// @notice Mints new tokens for a given address.\n  /// @param account The address to mint the new tokens to.\n  /// @param amount The number of tokens to be minted.\n  /// @dev this function increases the total supply.\n  function mint(address account, uint256 amount) external;\n\n  /// @notice Burns tokens from the sender.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burn(uint256 amount) external;\n\n  /// @notice Burns tokens from a given address..\n  /// @param account The address to burn tokens from.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burn(address account, uint256 amount) external;\n\n  /// @notice Burns tokens from a given address..\n  /// @param account The address to burn tokens from.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/BurnMintERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBurnMintERC20} from \"../ERC20/IBurnMintERC20.sol\";\nimport {IERC677} from \"./IERC677.sol\";\n\nimport {ERC677} from \"./ERC677.sol\";\nimport {OwnerIsCreator} from \"../../access/OwnerIsCreator.sol\";\n\nimport {ERC20Burnable} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableSet.sol\";\nimport {IERC165} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice A basic ERC677 compatible token contract with burn and minting roles.\n/// @dev The total supply can be limited during deployment.\ncontract BurnMintERC677 is IBurnMintERC20, ERC677, IERC165, ERC20Burnable, OwnerIsCreator {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error SenderNotMinter(address sender);\n  error SenderNotBurner(address sender);\n  error MaxSupplyExceeded(uint256 supplyAfterMint);\n\n  event MintAccessGranted(address indexed minter);\n  event BurnAccessGranted(address indexed burner);\n  event MintAccessRevoked(address indexed minter);\n  event BurnAccessRevoked(address indexed burner);\n\n  // @dev the allowed minter addresses\n  EnumerableSet.AddressSet internal s_minters;\n  // @dev the allowed burner addresses\n  EnumerableSet.AddressSet internal s_burners;\n\n  /// @dev The number of decimals for the token\n  uint8 internal immutable i_decimals;\n\n  /// @dev The maximum supply of the token, 0 if unlimited\n  uint256 internal immutable i_maxSupply;\n\n  constructor(string memory name, string memory symbol, uint8 decimals_, uint256 maxSupply_) ERC677(name, symbol) {\n    i_decimals = decimals_;\n    i_maxSupply = maxSupply_;\n  }\n\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC677).interfaceId ||\n      interfaceId == type(IBurnMintERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                            ERC20                             |\n  // ================================================================\n\n  /// @dev Returns the number of decimals used in its user representation.\n  function decimals() public view virtual override returns (uint8) {\n    return i_decimals;\n  }\n\n  /// @dev Returns the max supply of the token, 0 if unlimited.\n  function maxSupply() public view virtual returns (uint256) {\n    return i_maxSupply;\n  }\n\n  /// @dev Uses OZ ERC20 _transfer to disallow sending to address(0).\n  /// @dev Disallows sending to address(this)\n  function _transfer(address from, address to, uint256 amount) internal virtual override validAddress(to) {\n    super._transfer(from, to, amount);\n  }\n\n  /// @dev Uses OZ ERC20 _approve to disallow approving for address(0).\n  /// @dev Disallows approving for address(this)\n  function _approve(address owner, address spender, uint256 amount) internal virtual override validAddress(spender) {\n    super._approve(owner, spender, amount);\n  }\n\n  /// @dev Exists to be backwards compatible with the older naming convention.\n  function decreaseApproval(address spender, uint256 subtractedValue) external returns (bool success) {\n    return decreaseAllowance(spender, subtractedValue);\n  }\n\n  /// @dev Exists to be backwards compatible with the older naming convention.\n  function increaseApproval(address spender, uint256 addedValue) external {\n    increaseAllowance(spender, addedValue);\n  }\n\n  /// @notice Check if recipient is valid (not this contract address).\n  /// @param recipient the account we transfer/approve to.\n  /// @dev Reverts with an empty revert to be compatible with the existing link token when\n  /// the recipient is this contract address.\n  modifier validAddress(address recipient) virtual {\n    // solhint-disable-next-line reason-string, gas-custom-errors\n    if (recipient == address(this)) revert();\n    _;\n  }\n\n  // ================================================================\n  // |                      Burning & minting                       |\n  // ================================================================\n\n  /// @inheritdoc ERC20Burnable\n  /// @dev Uses OZ ERC20 _burn to disallow burning from address(0).\n  /// @dev Decreases the total supply.\n  function burn(uint256 amount) public override(IBurnMintERC20, ERC20Burnable) onlyBurner {\n    super.burn(amount);\n  }\n\n  /// @inheritdoc IBurnMintERC20\n  /// @dev Alias for BurnFrom for compatibility with the older naming convention.\n  /// @dev Uses burnFrom for all validation & logic.\n  function burn(address account, uint256 amount) public virtual override {\n    burnFrom(account, amount);\n  }\n\n  /// @inheritdoc ERC20Burnable\n  /// @dev Uses OZ ERC20 _burn to disallow burning from address(0).\n  /// @dev Decreases the total supply.\n  function burnFrom(address account, uint256 amount) public override(IBurnMintERC20, ERC20Burnable) onlyBurner {\n    super.burnFrom(account, amount);\n  }\n\n  /// @inheritdoc IBurnMintERC20\n  /// @dev Uses OZ ERC20 _mint to disallow minting to address(0).\n  /// @dev Disallows minting to address(this)\n  /// @dev Increases the total supply.\n  function mint(address account, uint256 amount) external override onlyMinter validAddress(account) {\n    if (i_maxSupply != 0 && totalSupply() + amount > i_maxSupply) revert MaxSupplyExceeded(totalSupply() + amount);\n\n    _mint(account, amount);\n  }\n\n  // ================================================================\n  // |                            Roles                             |\n  // ================================================================\n\n  /// @notice grants both mint and burn roles to `burnAndMinter`.\n  /// @dev calls public functions so this function does not require\n  /// access controls. This is handled in the inner functions.\n  function grantMintAndBurnRoles(address burnAndMinter) external {\n    grantMintRole(burnAndMinter);\n    grantBurnRole(burnAndMinter);\n  }\n\n  /// @notice Grants mint role to the given address.\n  /// @dev only the owner can call this function.\n  function grantMintRole(address minter) public onlyOwner {\n    if (s_minters.add(minter)) {\n      emit MintAccessGranted(minter);\n    }\n  }\n\n  /// @notice Grants burn role to the given address.\n  /// @dev only the owner can call this function.\n  function grantBurnRole(address burner) public onlyOwner {\n    if (s_burners.add(burner)) {\n      emit BurnAccessGranted(burner);\n    }\n  }\n\n  /// @notice Revokes mint role for the given address.\n  /// @dev only the owner can call this function.\n  function revokeMintRole(address minter) public onlyOwner {\n    if (s_minters.remove(minter)) {\n      emit MintAccessRevoked(minter);\n    }\n  }\n\n  /// @notice Revokes burn role from the given address.\n  /// @dev only the owner can call this function\n  function revokeBurnRole(address burner) public onlyOwner {\n    if (s_burners.remove(burner)) {\n      emit BurnAccessRevoked(burner);\n    }\n  }\n\n  /// @notice Returns all permissioned minters\n  function getMinters() public view returns (address[] memory) {\n    return s_minters.values();\n  }\n\n  /// @notice Returns all permissioned burners\n  function getBurners() public view returns (address[] memory) {\n    return s_burners.values();\n  }\n\n  // ================================================================\n  // |                            Access                            |\n  // ================================================================\n\n  /// @notice Checks whether a given address is a minter for this token.\n  /// @return true if the address is allowed to mint.\n  function isMinter(address minter) public view returns (bool) {\n    return s_minters.contains(minter);\n  }\n\n  /// @notice Checks whether a given address is a burner for this token.\n  /// @return true if the address is allowed to burn.\n  function isBurner(address burner) public view returns (bool) {\n    return s_burners.contains(burner);\n  }\n\n  /// @notice Checks whether the msg.sender is a permissioned minter for this token\n  /// @dev Reverts with a SenderNotMinter if the check fails\n  modifier onlyMinter() {\n    if (!isMinter(msg.sender)) revert SenderNotMinter(msg.sender);\n    _;\n  }\n\n  /// @notice Checks whether the msg.sender is a permissioned burner for this token\n  /// @dev Reverts with a SenderNotBurner if the check fails\n  modifier onlyBurner() {\n    if (!isBurner(msg.sender)) revert SenderNotBurner(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/ERC677.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC677} from \"./IERC677.sol\";\nimport {IERC677Receiver} from \"../../interfaces/IERC677Receiver.sol\";\n\nimport {ERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC677 is IERC677, ERC20 {\n  constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n  /// @inheritdoc IERC677\n  function transferAndCall(address to, uint256 amount, bytes memory data) public returns (bool success) {\n    super.transfer(to, amount);\n    emit Transfer(msg.sender, to, amount, data);\n    if (to.code.length > 0) {\n      IERC677Receiver(to).onTokenTransfer(msg.sender, amount, data);\n    }\n    return true;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/IERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677 {\n  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n\n  /// @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n  /// @param to The address which you want to transfer to\n  /// @param amount The amount of tokens to be transferred\n  /// @param data bytes Additional data with no specified format, sent in call to `to`\n  /// @return true unless throwing\n  function transferAndCall(address to, uint256 amount, bytes memory data) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n      // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n      // decrementing then incrementing.\n      _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    unchecked {\n      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n      _balances[account] += amount;\n    }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n      // Overflow not possible: amount <= accountBalance <= totalSupply.\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n   * given ``owner``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for ``accounts``'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) public virtual {\n    _spendAllowance(account, _msgSender(), amount);\n    _burn(account, amount);\n  }\n}"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/FunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IFunctionsRouter} from \"./interfaces/IFunctionsRouter.sol\";\nimport {IFunctionsClient} from \"./interfaces/IFunctionsClient.sol\";\n\nimport {FunctionsRequest} from \"./libraries/FunctionsRequest.sol\";\n\n/// @title The Chainlink Functions client contract\n/// @notice Contract developers can inherit this contract in order to make Chainlink Functions requests\nabstract contract FunctionsClient is IFunctionsClient {\n  using FunctionsRequest for FunctionsRequest.Request;\n\n  IFunctionsRouter internal immutable i_router;\n\n  event RequestSent(bytes32 indexed id);\n  event RequestFulfilled(bytes32 indexed id);\n\n  error OnlyRouterCanFulfill();\n\n  constructor(address router) {\n    i_router = IFunctionsRouter(router);\n  }\n\n  /// @notice Sends a Chainlink Functions request\n  /// @param data The CBOR encoded bytes data for a Functions request\n  /// @param subscriptionId The subscription ID that will be charged to service the request\n  /// @param callbackGasLimit the amount of gas that will be available for the fulfillment callback\n  /// @return requestId The generated request ID for this request\n  function _sendRequest(\n    bytes memory data,\n    uint64 subscriptionId,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) internal returns (bytes32) {\n    bytes32 requestId = i_router.sendRequest(\n      subscriptionId,\n      data,\n      FunctionsRequest.REQUEST_DATA_VERSION,\n      callbackGasLimit,\n      donId\n    );\n    emit RequestSent(requestId);\n    return requestId;\n  }\n\n  /// @notice User defined function to handle a response from the DON\n  /// @param requestId The request ID, returned by sendRequest()\n  /// @param response Aggregated response from the execution of the user's source code\n  /// @param err Aggregated error from the execution of the user code or from the execution pipeline\n  /// @dev Either response or error parameter will be set, but never both\n  function fulfillRequest(bytes32 requestId, bytes memory response, bytes memory err) internal virtual;\n\n  /// @inheritdoc IFunctionsClient\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external override {\n    if (msg.sender != address(i_router)) {\n      revert OnlyRouterCanFulfill();\n    }\n    fulfillRequest(requestId, response, err);\n    emit RequestFulfilled(requestId);\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Chainlink Functions client interface.\ninterface IFunctionsClient {\n  /// @notice Chainlink Functions response handler called by the Functions Router\n  /// during fullilment from the designated transmitter node in an OCR round.\n  /// @param requestId The requestId returned by FunctionsClient.sendRequest().\n  /// @param response Aggregated response from the request's source code.\n  /// @param err Aggregated error either from the request's source code or from the execution pipeline.\n  /// @dev Either response or error parameter will be set, but never both.\n  function handleOracleFulfillment(bytes32 requestId, bytes memory response, bytes memory err) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/interfaces/IFunctionsRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {FunctionsResponse} from \"../libraries/FunctionsResponse.sol\";\n\n/// @title Chainlink Functions Router interface.\ninterface IFunctionsRouter {\n  /// @notice The identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  /// @return id - bytes32 id that can be passed to the \"getContractById\" of the Router\n  function getAllowListId() external view returns (bytes32);\n\n  /// @notice Set the identifier of the route to retrieve the address of the access control contract\n  /// The access control contract controls which accounts can manage subscriptions\n  function setAllowListId(bytes32 allowListId) external;\n\n  /// @notice Get the flat fee (in Juels of LINK) that will be paid to the Router owner for operation of the network\n  /// @return adminFee\n  function getAdminFee() external view returns (uint72 adminFee);\n\n  /// @notice Sends a request using the provided subscriptionId\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequest(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Sends a request to the proposed contracts\n  /// @param subscriptionId - A unique subscription ID allocated by billing system,\n  /// a client can make requests from different contracts referencing the same subscription\n  /// @param data - CBOR encoded Chainlink Functions request data, use FunctionsClient API to encode a request\n  /// @param dataVersion - Gas limit for the fulfillment callback\n  /// @param callbackGasLimit - Gas limit for the fulfillment callback\n  /// @param donId - An identifier used to determine which route to send the request along\n  /// @return requestId - A unique request identifier\n  function sendRequestToProposed(\n    uint64 subscriptionId,\n    bytes calldata data,\n    uint16 dataVersion,\n    uint32 callbackGasLimit,\n    bytes32 donId\n  ) external returns (bytes32);\n\n  /// @notice Fulfill the request by:\n  /// - calling back the data that the Oracle returned to the client contract\n  /// - pay the DON for processing the request\n  /// @dev Only callable by the Coordinator contract that is saved in the commitment\n  /// @param response response data from DON consensus\n  /// @param err error from DON consensus\n  /// @param juelsPerGas - current rate of juels/gas\n  /// @param costWithoutFulfillment - The cost of processing the request (in Juels of LINK ), without fulfillment\n  /// @param transmitter - The Node that transmitted the OCR report\n  /// @param commitment - The parameters of the request that must be held consistent between request and response time\n  /// @return fulfillResult -\n  /// @return callbackGasCostJuels -\n  function fulfill(\n    bytes memory response,\n    bytes memory err,\n    uint96 juelsPerGas,\n    uint96 costWithoutFulfillment,\n    address transmitter,\n    FunctionsResponse.Commitment memory commitment\n  ) external returns (FunctionsResponse.FulfillResult, uint96);\n\n  /// @notice Validate requested gas limit is below the subscription max.\n  /// @param subscriptionId subscription ID\n  /// @param callbackGasLimit desired callback gas limit\n  function isValidCallbackGasLimit(uint64 subscriptionId, uint32 callbackGasLimit) external view;\n\n  /// @notice Get the current contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current contract address\n  function getContractById(bytes32 id) external view returns (address);\n\n  /// @notice Get the proposed next contract given an ID\n  /// @param id A bytes32 identifier for the route\n  /// @return contract The current or proposed contract address\n  function getProposedContractById(bytes32 id) external view returns (address);\n\n  /// @notice Return the latest proprosal set\n  /// @return ids The identifiers of the contracts to update\n  /// @return to The addresses of the contracts that will be updated to\n  function getProposedContractSet() external view returns (bytes32[] memory, address[] memory);\n\n  /// @notice Proposes one or more updates to the contract routes\n  /// @dev Only callable by owner\n  function proposeContractsUpdate(bytes32[] memory proposalSetIds, address[] memory proposalSetAddresses) external;\n\n  /// @notice Updates the current contract routes to the proposed contracts\n  /// @dev Only callable by owner\n  function updateContracts() external;\n\n  /// @dev Puts the system into an emergency stopped state.\n  /// @dev Only callable by owner\n  function pause() external;\n\n  /// @dev Takes the system out of an emergency stopped state.\n  /// @dev Only callable by owner\n  function unpause() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsRequest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CBOR} from \"../../../vendor/solidity-cborutils/v2.0.0/CBOR.sol\";\n\n/// @title Library for encoding the input data of a Functions request into CBOR\nlibrary FunctionsRequest {\n  using CBOR for CBOR.CBORBuffer;\n\n  uint16 public constant REQUEST_DATA_VERSION = 1;\n  uint256 internal constant DEFAULT_BUFFER_SIZE = 256;\n\n  enum Location {\n    Inline, // Provided within the Request\n    Remote, // Hosted through remote location that can be accessed through a provided URL\n    DONHosted // Hosted on the DON's storage\n  }\n\n  enum CodeLanguage {\n    JavaScript\n    // In future version we may add other languages\n  }\n\n  struct Request {\n    Location codeLocation; // ════════════╸ The location of the source code that will be executed on each node in the DON\n    Location secretsLocation; // ═════════╸ The location of secrets that will be passed into the source code. *Only Remote secrets are supported\n    CodeLanguage language; // ════════════╸ The coding language that the source code is written in\n    string source; // ════════════════════╸ Raw source code for Request.codeLocation of Location.Inline, URL for Request.codeLocation of Location.Remote, or slot decimal number for Request.codeLocation of Location.DONHosted\n    bytes encryptedSecretsReference; // ══╸ Encrypted URLs for Request.secretsLocation of Location.Remote (use addSecretsReference()), or CBOR encoded slotid+version for Request.secretsLocation of Location.DONHosted (use addDONHostedSecrets())\n    string[] args; // ════════════════════╸ String arguments that will be passed into the source code\n    bytes[] bytesArgs; // ════════════════╸ Bytes arguments that will be passed into the source code\n  }\n\n  error EmptySource();\n  error EmptySecrets();\n  error EmptyArgs();\n  error NoInlineSecrets();\n\n  /// @notice Encodes a Request to CBOR encoded bytes\n  /// @param self The request to encode\n  /// @return CBOR encoded bytes\n  function encodeCBOR(Request memory self) internal pure returns (bytes memory) {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"codeLocation\");\n    buffer.writeUInt256(uint256(self.codeLocation));\n\n    buffer.writeString(\"language\");\n    buffer.writeUInt256(uint256(self.language));\n\n    buffer.writeString(\"source\");\n    buffer.writeString(self.source);\n\n    if (self.args.length > 0) {\n      buffer.writeString(\"args\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.args.length; ++i) {\n        buffer.writeString(self.args[i]);\n      }\n      buffer.endSequence();\n    }\n\n    if (self.encryptedSecretsReference.length > 0) {\n      if (self.secretsLocation == Location.Inline) {\n        revert NoInlineSecrets();\n      }\n      buffer.writeString(\"secretsLocation\");\n      buffer.writeUInt256(uint256(self.secretsLocation));\n      buffer.writeString(\"secrets\");\n      buffer.writeBytes(self.encryptedSecretsReference);\n    }\n\n    if (self.bytesArgs.length > 0) {\n      buffer.writeString(\"bytesArgs\");\n      buffer.startArray();\n      for (uint256 i = 0; i < self.bytesArgs.length; ++i) {\n        buffer.writeBytes(self.bytesArgs[i]);\n      }\n      buffer.endSequence();\n    }\n\n    return buffer.buf.buf;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Sets the codeLocation and code on the request\n  /// @param self The uninitialized request\n  /// @param codeLocation The user provided source code location\n  /// @param language The programming language of the user code\n  /// @param source The user provided source code or a url\n  function initializeRequest(\n    Request memory self,\n    Location codeLocation,\n    CodeLanguage language,\n    string memory source\n  ) internal pure {\n    if (bytes(source).length == 0) revert EmptySource();\n\n    self.codeLocation = codeLocation;\n    self.language = language;\n    self.source = source;\n  }\n\n  /// @notice Initializes a Chainlink Functions Request\n  /// @dev Simplified version of initializeRequest for PoC\n  /// @param self The uninitialized request\n  /// @param javaScriptSource The user provided JS code (must not be empty)\n  function initializeRequestForInlineJavaScript(Request memory self, string memory javaScriptSource) internal pure {\n    initializeRequest(self, Location.Inline, CodeLanguage.JavaScript, javaScriptSource);\n  }\n\n  /// @notice Adds Remote user encrypted secrets to a Request\n  /// @param self The initialized request\n  /// @param encryptedSecretsReference Encrypted comma-separated string of URLs pointing to off-chain secrets\n  function addSecretsReference(Request memory self, bytes memory encryptedSecretsReference) internal pure {\n    if (encryptedSecretsReference.length == 0) revert EmptySecrets();\n\n    self.secretsLocation = Location.Remote;\n    self.encryptedSecretsReference = encryptedSecretsReference;\n  }\n\n  /// @notice Adds DON-hosted secrets reference to a Request\n  /// @param self The initialized request\n  /// @param slotID Slot ID of the user's secrets hosted on DON\n  /// @param version User data version (for the slotID)\n  function addDONHostedSecrets(Request memory self, uint8 slotID, uint64 version) internal pure {\n    CBOR.CBORBuffer memory buffer = CBOR.create(DEFAULT_BUFFER_SIZE);\n\n    buffer.writeString(\"slotID\");\n    buffer.writeUInt64(slotID);\n    buffer.writeString(\"version\");\n    buffer.writeUInt64(version);\n\n    self.secretsLocation = Location.DONHosted;\n    self.encryptedSecretsReference = buffer.buf.buf;\n  }\n\n  /// @notice Sets args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of string args (must not be empty)\n  function setArgs(Request memory self, string[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.args = args;\n  }\n\n  /// @notice Sets bytes args for the user run function\n  /// @param self The initialized request\n  /// @param args The array of bytes args (must not be empty)\n  function setBytesArgs(Request memory self, bytes[] memory args) internal pure {\n    if (args.length == 0) revert EmptyArgs();\n\n    self.bytesArgs = args;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/functions/v1_0_0/libraries/FunctionsResponse.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n/// @title Library of types that are used for fulfillment of a Functions request\nlibrary FunctionsResponse {\n  // Used to send request information from the Router to the Coordinator\n  struct RequestMeta {\n    bytes data; // ══════════════════╸ CBOR encoded Chainlink Functions request data, use FunctionsRequest library to encode a request\n    bytes32 flags; // ═══════════════╸ Per-subscription flags\n    address requestingContract; // ══╗ The client contract that is sending the request\n    uint96 availableBalance; // ═════╝ Common LINK balance of the subscription that is controlled by the Router to be used for all consumer requests.\n    uint72 adminFee; // ═════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint64 subscriptionId; //        ║ Identifier of the billing subscription that will be charged for the request\n    uint64 initiatedRequests; //     ║ The number of requests that have been started\n    uint32 callbackGasLimit; //      ║ The amount of gas that the callback to the consuming contract will be given\n    uint16 dataVersion; // ══════════╝ The version of the structure of the CBOR encoded request data\n    uint64 completedRequests; // ════╗ The number of requests that have successfully completed or timed out\n    address subscriptionOwner; // ═══╝ The owner of the billing subscription\n  }\n\n  enum FulfillResult {\n    FULFILLED, // 0\n    USER_CALLBACK_ERROR, // 1\n    INVALID_REQUEST_ID, // 2\n    COST_EXCEEDS_COMMITMENT, // 3\n    INSUFFICIENT_GAS_PROVIDED, // 4\n    SUBSCRIPTION_BALANCE_INVARIANT_VIOLATION, // 5\n    INVALID_COMMITMENT // 6\n  }\n\n  struct Commitment {\n    bytes32 requestId; // ═════════════════╸ A unique identifier for a Chainlink Functions request\n    address coordinator; // ═══════════════╗ The Coordinator contract that manages the DON that is servicing a request\n    uint96 estimatedTotalCostJuels; // ════╝ The maximum cost in Juels (1e18) of LINK that will be charged to fulfill a request\n    address client; // ════════════════════╗ The client contract that sent the request\n    uint64 subscriptionId; //              ║ Identifier of the billing subscription that will be charged for the request\n    uint32 callbackGasLimit; // ═══════════╝ The amount of gas that the callback to the consuming contract will be given\n    uint72 adminFee; // ═══════════════════╗ Flat fee (in Juels of LINK) that will be paid to the Router Owner for operation of the network\n    uint72 donFee; //                      ║ Fee (in Juels of LINK) that will be split between Node Operators for servicing a request\n    uint40 gasOverheadBeforeCallback; //   ║ Represents the average gas execution cost before the fulfillment callback.\n    uint40 gasOverheadAfterCallback; //    ║ Represents the average gas execution cost after the fulfillment callback.\n    uint32 timeoutTimestamp; // ═══════════╝ The timestamp at which a request will be eligible to be timed out\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vendor/@ensdomains/buffer/v0.1.0/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/vendor/solidity-cborutils/v2.0.0/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../../@ensdomains/buffer/v0.1.0/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "@chainlink/local/src/ccip/BurnMintERC677Helper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {BurnMintERC677} from \"@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/BurnMintERC677.sol\";\n\n/// @title BurnMintERC677Helper\n/// @notice This contract extends the functionality of the BurnMintERC677 token contract to include a `drip` function that mints one full token to a specified address.\n/// @dev Inherits from the BurnMintERC677 contract and sets the token name, symbol, decimals, and initial supply in the constructor.\ncontract BurnMintERC677Helper is BurnMintERC677 {\n    /**\n     * @notice Constructor to initialize the BurnMintERC677Helper contract with a name and symbol.\n     * @dev Calls the parent constructor of BurnMintERC677 with fixed decimals (18) and initial supply (0).\n     * @param name - The name of the token.\n     * @param symbol - The symbol of the token.\n     */\n    constructor(\n        string memory name,\n        string memory symbol\n    ) BurnMintERC677(name, symbol, 18, 0) {}\n\n    /**\n     * @notice Mints one full token (1e18) to the specified address.\n     * @dev Calls the internal `_mint` function from the BurnMintERC677 contract.\n     * @param to - The address to receive the minted token.\n     */\n    function drip(address to) external {\n        _mint(to, 1e18);\n    }\n}\n"
    },
    "@chainlink/local/src/ccip/CCIPLocalSimulator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {WETH9} from \"../shared/WETH9.sol\";\nimport {LinkToken} from \"../shared/LinkToken.sol\";\nimport {BurnMintERC677Helper} from \"./BurnMintERC677Helper.sol\";\nimport {MockCCIPRouter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/test/mocks/MockRouter.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IOwner} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IOwner.sol\";\nimport {IGetCCIPAdmin} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IGetCCIPAdmin.sol\";\n\n/// @title CCIPLocalSimulator\n/// @notice This contract simulates local CCIP (Cross-Chain Interoperability Protocol) operations for testing and development purposes.\n/// @dev This contract includes methods to manage supported tokens and configurations for local simulations.\ncontract CCIPLocalSimulator {\n    using SafeERC20 for IERC20;\n\n    /// @notice The unique CCIP Chain Selector constant\n    uint64 constant CHAIN_SELECTOR = 16015286601757825753;\n\n    /// @notice The wrapped native token instance\n    WETH9 internal immutable i_wrappedNative;\n\n    /// @notice The LINK token instance\n    LinkToken internal immutable i_linkToken;\n\n    /// @notice The BurnMintERC677Helper instance for CCIP-BnM token\n    BurnMintERC677Helper internal immutable i_ccipBnM;\n\n    /// @notice The BurnMintERC677Helper instance for CCIP-LnM token\n    BurnMintERC677Helper internal immutable i_ccipLnM;\n\n    /// @notice The mock CCIP router instance\n    MockCCIPRouter internal immutable i_mockRouter;\n\n    /// @notice The list of supported token addresses\n    address[] internal s_supportedTokens;\n\n    error CCIPLocalSimulator__MsgSenderIsNotTokenOwner();\n\n    /**\n     * @notice Constructor to initialize the contract and pre-deployed token instances\n     */\n    constructor() {\n        i_wrappedNative = new WETH9();\n        i_linkToken = new LinkToken();\n        i_ccipBnM = new BurnMintERC677Helper(\"CCIP-BnM\", \"CCIP-BnM\");\n        i_ccipLnM = new BurnMintERC677Helper(\"CCIP-LnM\", \"CCIP-LnM\");\n        i_mockRouter = new MockCCIPRouter();\n\n        s_supportedTokens.push(address(i_ccipBnM));\n        s_supportedTokens.push(address(i_ccipLnM));\n    }\n\n    /**\n     * @notice Allows user to support any new token, besides CCIP BnM and CCIP LnM, for cross-chain transfers.\n     *         Reverts if token does not implement owner() function.\n     *         Reverts if the caller is not the token owner.\n     *\n     * @param tokenAddress - The address of the token to add to the list of supported tokens.\n     */\n    function supportNewTokenViaOwner(address tokenAddress) external {\n        if (msg.sender != IOwner(tokenAddress).owner()) {\n            revert CCIPLocalSimulator__MsgSenderIsNotTokenOwner();\n        }\n        s_supportedTokens.push(tokenAddress);\n    }\n\n    /**\n     * @notice Allows user to support any new token, besides CCIP BnM and CCIP LnM, for cross-chain transfers.\n     *         Reverts if token does not implement getCCIPAdmin() function.\n     *         Reverts if the caller is not the token CCIPAdmin.\n     *\n     * @param tokenAddress - The address of the token to add to the list of supported tokens.\n     */\n    function supportNewTokenViaGetCCIPAdmin(address tokenAddress) external {\n        if (msg.sender != IGetCCIPAdmin(tokenAddress).getCCIPAdmin()) {\n            revert CCIPLocalSimulator__MsgSenderIsNotTokenOwner();\n        }\n        s_supportedTokens.push(tokenAddress);\n    }\n\n    /**\n     * @notice Checks whether the provided `chainSelector` is supported by the simulator.\n     *\n     * @param chainSelector - The unique CCIP Chain Selector.\n     *\n     * @return supported - Returns true if `chainSelector` is supported by the simulator.\n     */\n    function isChainSupported(uint64 chainSelector) public pure returns (bool supported) {\n        supported = chainSelector == CHAIN_SELECTOR;\n    }\n\n    /**\n     * @notice Gets a list of token addresses that are supported for cross-chain transfers by the simulator.\n     *\n     * @param chainSelector - The unique CCIP Chain Selector.\n     *\n     * @return tokens - Returns a list of token addresses that are supported for cross-chain transfers by the simulator.\n     */\n    function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens) {\n        if (!isChainSupported(chainSelector)) {\n            return new address[](0);\n        }\n\n        tokens = s_supportedTokens;\n    }\n\n    /**\n     * @notice Requests LINK tokens from the faucet. The provided amount of tokens are transferred to provided destination address.\n     *\n     * @param to - The address to which LINK tokens are to be sent.\n     * @param amount - The amount of LINK tokens to send.\n     *\n     * @return success - Returns `true` if the transfer of tokens was successful, otherwise `false`.\n     */\n    function requestLinkFromFaucet(address to, uint256 amount) external returns (bool success) {\n        success = i_linkToken.transfer(to, amount);\n    }\n\n    /**\n     * @notice Returns configuration details for pre-deployed contracts and services needed for local CCIP simulations.\n     *\n     * @return chainSelector_ - The unique CCIP Chain Selector.\n     * @return sourceRouter_  - The source chain Router contract.\n     * @return destinationRouter_ - The destination chain Router contract.\n     * @return wrappedNative_ - The wrapped native token which can be used for CCIP fees.\n     * @return linkToken_ - The LINK token.\n     * @return ccipBnM_ - The ccipBnM token.\n     * @return ccipLnM_ - The ccipLnM token.\n     */\n    function configuration()\n        public\n        view\n        returns (\n            uint64 chainSelector_,\n            IRouterClient sourceRouter_,\n            IRouterClient destinationRouter_,\n            WETH9 wrappedNative_,\n            LinkToken linkToken_,\n            BurnMintERC677Helper ccipBnM_,\n            BurnMintERC677Helper ccipLnM_\n        )\n    {\n        return (\n            CHAIN_SELECTOR,\n            IRouterClient(address(i_mockRouter)),\n            IRouterClient(address(i_mockRouter)),\n            i_wrappedNative,\n            i_linkToken,\n            i_ccipBnM,\n            i_ccipLnM\n        );\n    }\n}\n"
    },
    "@chainlink/local/src/shared/LinkToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {ERC677} from \"@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/ERC677.sol\";\n\n/// @title LinkToken\n/// @notice This contract implements the ChainLink Token (LINK) using the ERC677 standard.\n/// @dev Inherits from the ERC677 token contract and initializes with a fixed total supply and standard token details.\ncontract LinkToken is ERC677 {\n    /// @notice The total supply of LINK tokens.\n    uint private constant TOTAL_SUPPLY = 10 ** 27;\n\n    /// @notice The name of the LINK token.\n    string private constant NAME = \"ChainLink Token\";\n\n    /// @notice The symbol of the LINK token.\n    string private constant SYMBOL = \"LINK\";\n\n    /**\n     * @notice Constructor to initialize the LinkToken contract with a fixed total supply, name, and symbol.\n     * @dev Calls the ERC677 constructor with the name and symbol, and then mints the total supply to the contract deployer.\n     */\n    constructor() ERC677(NAME, SYMBOL) {\n        _onCreate();\n    }\n\n    /**\n     * @notice Hook that is called when this contract is created.\n     * @dev Useful to override constructor behaviour in child contracts (e.g., LINK bridge tokens).\n     *      The default implementation mints 10**27 tokens to the contract deployer.\n     */\n    function _onCreate() internal virtual {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n}\n"
    },
    "@chainlink/local/src/shared/WETH9.sol": {
      "content": "// Submitted for verification at Etherscan.io on 2017-12-12\n\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\npragma solidity ^0.8.19;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        _deposit();\n    }\n\n    function _deposit() internal {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function deposit() external payable {\n        _deposit();\n    }\n\n    function withdraw(uint256 wad) external {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint128).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n}\n"
    },
    "src/_testContracts/VerifierUser.sol": {
      "content": "/* solhint-disable */\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"../verifiers/Verifier.sol\";\n\ncontract VerifierUser is Verifier {\n\tconstructor() Verifier() {}\n\n\tfunction doSomething() public onlyVerifiedSender {}\n}\n"
    },
    "src/bridge/Bridge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\n// Chainlink\nimport { IRouterClient } from '@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol';\nimport { CCIPReceiver } from '@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol';\nimport { Client } from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\n// OpenZeppelin\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\nimport { ReentrancyGuard } from '@openzeppelin/contracts/security/ReentrancyGuard.sol';\n// Interfaces\nimport { IIdentity } from '../interface/IIdentity.sol';\nimport { Gateway } from '../gateway/Gateway.sol';\nimport '../factory/IIdFactory.sol';\n\ncontract CrossChainBridge is CCIPReceiver, ReentrancyGuard {\n  /// @notice REMOVE for prod\n  string public ccipMessage;\n\n  address immutable i_router;\n  address public idFactoryAddress;\n\n  // Map to store the messageIds of the messages sent\n  mapping(bytes32 => bool) public messageIds;\n\n  // Map to store allowedContracts\n  mapping(address => bool) public isAllowedContract;\n\n  // Map to store onlyManagers\n  mapping(address => bool) public isManager;\n\n  // Define the enum\n  enum AccessAddressTypes {\n    CONTRACT,\n    MANAGER\n  }\n\n  modifier onlyAllowedSender {\n    require(\n      isAllowedContract[msg.sender] == true || isManager[msg.sender] == true,\n      'Permissions: Sender is not a allowed'\n    );\n    _;\n  }\n\n  modifier onlyAllowedContract() {\n    require(isAllowedContract[msg.sender] == true, 'Permissions: Sender is not a allowed contract');\n    _;\n  }\n\n  modifier onlyManager() {\n    require(isManager[msg.sender] == true, 'Permissions: Sender is not a Manager');\n    _;\n  }\n\n  modifier onlyAllowedIdentity(address _identity) {\n    IIdFactory idFactory = IIdFactory(idFactoryAddress);\n    require(idFactory.identityIsCreated(_identity), 'Permissions: idFactory marks this address as not identity');\n    _;\n  }\n\n  event AllowedAddress(address indexed _address, uint64 indexed _type, bool indexed _status);\n\n  event MessageSent(bytes32 indexed messageId);\n  event MessageReceived(\n    bytes32 messageId,\n    uint64 indexed sourceChainSelector,\n    address indexed sender,\n    string indexed action\n  );\n  event IdFactoryUpdated(address indexed sender, address indexed newAddress);\n\n  constructor(address _router) CCIPReceiver(_router) {\n    i_router = _router;\n    isManager[msg.sender] = true;\n    emit AllowedAddress(msg.sender, uint64(AccessAddressTypes.MANAGER), true);\n  }\n\n  receive() external payable {}\n\n  function setFactoryAddress(address _idFactoryAddress) external onlyManager {\n    idFactoryAddress = _idFactoryAddress;\n    emit IdFactoryUpdated(msg.sender, _idFactoryAddress);\n  }\n\n  function sendAddClaim(\n    uint64 destinationChainSelector,\n    address receiver,\n    uint256 topic,\n    uint256 scheme,\n    address issuer,\n    bytes memory signature,\n    bytes memory data,\n    string memory uri\n  ) external onlyAllowedIdentity(msg.sender) {\n    bytes memory _payload = abi.encode(msg.sender, topic, scheme, issuer, signature, data, uri);\n    bytes memory metaPayload = abi.encode('AddClaim', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendRemoveClaim(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes32 claimId\n  ) external onlyAllowedIdentity(msg.sender) {\n    bytes memory _payload = abi.encode(msg.sender, claimId);\n    bytes memory metaPayload = abi.encode('RemoveClaim',_payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendAddKey(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes32 key,\n    uint256 purpose,\n    uint256 keyType\n  ) external onlyAllowedIdentity(msg.sender) {\n    bytes memory _payload = abi.encode(msg.sender, key, purpose, keyType);\n    bytes memory metaPayload = abi.encode('AddKey', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendRemoveKey(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes32 key,\n    uint256 purpose\n  ) external onlyAllowedIdentity(msg.sender) {\n     bytes memory _payload = abi.encode(msg.sender, key, purpose);\n    bytes memory metaPayload = abi.encode('RemoveKey', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function sendCreateIdentity(\n    uint64 destinationChainSelector,\n    address receiver,\n    address gateway,\n    address identityOwner,\n    string memory salt,\n    bytes32[] calldata managementKeys\n  ) external onlyAllowedSender {\n    bytes memory _payload = abi.encode(gateway, identityOwner, salt, managementKeys);\n    bytes memory metaPayload = abi.encode('CreateIdentity', _payload);\n    _sendMessage(destinationChainSelector, receiver, metaPayload);\n  }\n\n  function _sendMessage(uint64 destinationChainSelector, address receiver, bytes memory payload) internal nonReentrant {\n    (uint256 fee, Client.EVM2AnyMessage memory message) = calculateFeeAndMessage(\n      destinationChainSelector,\n      receiver,\n      payload\n    );\n\n    bytes32 messageId = IRouterClient(i_router).ccipSend{ value: fee }(destinationChainSelector, message);\n\n    emit MessageSent(messageId);\n  }\n\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal override {\n    // Check if the message was already processed\n    require(!messageIds[message.messageId], 'Message already processed');\n    messageIds[message.messageId] = true;\n    // Decode the message data\n    (string memory action, bytes memory _payload) = abi.decode(message.data, (string, bytes));\n    if (keccak256(bytes(action)) == keccak256(bytes('AddClaim'))) {\n        (\n          address targetContract,\n          uint256 topic,\n          uint256 scheme,\n          address issuer,\n          bytes memory signature,\n          bytes memory decodedData,\n          string memory uri\n        ) = abi.decode(_payload, (address, uint256, uint256, address, bytes, bytes, string));\n        IIdentity(targetContract).addClaim(topic, scheme, issuer, signature, decodedData, uri);\n      } else if (keccak256(bytes(action)) == keccak256(bytes('RemoveClaim'))) {\n        (address targetIdentity, bytes32 claimId) = abi.decode(_payload, (address,bytes32));\n        IIdentity(targetIdentity).removeClaim(claimId);\n    } else if (keccak256(bytes(action)) == keccak256(bytes('AddKey'))) {\n      (address targetIdentity, bytes32 key, uint256 purpose, uint256 keyType) = abi.decode(\n        _payload,\n        (address, bytes32, uint256, uint256)\n      );\n      IIdentity(targetIdentity).addKey(key, purpose, keyType);\n      } else if (keccak256(bytes(action)) == keccak256(bytes('RemoveKey'))) {\n        (address targetIdentity, bytes32 key, uint256 purpose) = abi.decode(_payload, (address, bytes32, uint256));\n        IIdentity(targetIdentity).removeKey(key, purpose);\n    } else if (keccak256(bytes(action)) == keccak256(bytes('CreateIdentity'))) {\n      (address targetContract, address identityOwner, string memory salt, bytes32[] memory managementKeys) = abi.decode(\n        _payload,\n        (address, address, string, bytes32[])\n      );\n      Gateway(targetContract).deployIdentity(identityOwner, salt, managementKeys);\n    } else {\n      revert('Unknown action');\n    }\n    emit MessageReceived(message.messageId, message.sourceChainSelector, abi.decode(message.sender, (address)), action);\n  }\n\n  // Function to set allowed contracts\n  function setAllowedContract(address _contract, bool _status) external onlyManager {\n    if (_status == true) {\n      require(Address.isContract(_contract), 'Permissions: Address is not a contract');\n    }\n    isAllowedContract[_contract] = _status;\n\n    emit AllowedAddress(_contract, uint64(AccessAddressTypes.CONTRACT), _status);\n  }\n\n  // Function to set manager status\n  function setManager(address _manager, bool _status) external onlyManager {\n    isManager[_manager] = _status;\n\n    emit AllowedAddress(_manager, uint64(AccessAddressTypes.MANAGER), _status);\n  }\n\n  /// @notice REMOVE for prod\n  function testSendMessage(\n    uint64 _destinationChainSelector,\n    address _receiver,\n    string memory _message\n  ) public onlyAllowedSender {\n    bytes memory payload = abi.encode(_message);\n    _sendMessage(_destinationChainSelector, _receiver, payload);\n  }\n\n  /// @notice REMOVE for prod\n  function _testRecieveMessage(Client.Any2EVMMessage memory any2EvmMessage) internal {\n    bytes32 s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\n    ccipMessage = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text\n    emit MessageReceived(s_lastReceivedMessageId, 0, msg.sender, ccipMessage);\n  }\n\n  function calculateFeeAndMessage(\n    uint64 destinationChainSelector,\n    address receiver,\n    bytes memory payload\n  ) public view returns (uint256 fee, Client.EVM2AnyMessage memory message) {\n    message = Client.EVM2AnyMessage({\n      receiver: abi.encode(receiver),\n      data: payload,\n      tokenAmounts: new Client.EVMTokenAmount[](0),\n      extraArgs: Client._argsToBytes(Client.EVMExtraArgsV1({ gasLimit: 1000000 })),\n      feeToken: address(0) // Use native token\n    });\n    fee = IRouterClient(i_router).getFee(destinationChainSelector, message);\n    return (fee, message);\n  }\n\n  // Function to withdraw native token from the contract\n  function withdraw(address _to, uint256 _amount) external onlyManager nonReentrant {\n    require(address(this).balance >= _amount, 'Insufficient balance');\n    Address.sendValue(payable(_to), _amount);\n  }\n}\n"
    },
    "src/ccip/CCIPLocalSimulator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport { CCIPLocalSimulator } from '@chainlink/local/src/ccip/CCIPLocalSimulator.sol';\n\n// pragma solidity ^0.8.19;\n\n// import { CCIPLocalSimulator, IRouterClient, WETH9, LinkToken, BurnMintERC677Helper } from '@chainlink/local/src/ccip/CCIPLocalSimulator.sol';\n\n// contract Demo {\n//   CCIPLocalSimulator public ccipLocalSimulator;\n\n//   function setUp() public {\n//     ccipLocalSimulator = new CCIPLocalSimulator();\n\n//     (\n//       uint64 chainSelector,\n//       IRouterClient sourceRouter,\n//       IRouterClient destinationRouter,\n//       WETH9 wrappedNative,\n//       LinkToken linkToken,\n//       BurnMintERC677Helper ccipBnM,\n//       BurnMintERC677Helper ccipLnM\n//     ) = ccipLocalSimulator.configuration();\n//   }\n// }\n"
    },
    "src/ccip/CCIPReceiver_Unsafe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport { CCIPReceiver } from '@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol';\nimport { Client } from '@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol';\n\n/**\n * THIS IS AN EXAMPLE CONTRACT THAT USES HARDCODED VALUES FOR CLARITY.\n * THIS IS AN EXAMPLE CONTRACT THAT USES UN-AUDITED CODE.\n * DO NOT USE THIS CODE IN PRODUCTION.\n */\n\n/// @title - A simple contract for receiving string data across chains.\ncontract Receiver is CCIPReceiver {\n  // Event emitted when a message is received from another chain.\n  event MessageReceived(\n    bytes32 indexed messageId, // The unique ID of the message.\n    uint64 indexed sourceChainSelector, // The chain selector of the source chain.\n    address sender, // The address of the sender from the source chain.\n    string text // The text that was received.\n  );\n\n  bytes32 private s_lastReceivedMessageId = bytes32(0); // Store the last received messageId.\n  string private s_lastReceivedText = ''; // Store the last received text.\n\n  /// @notice Constructor initializes the contract with the router address.\n  /// @param router The address of the router contract.\n  constructor(address router) CCIPReceiver(router) {}\n\n  /// handle a received message\n  function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n    s_lastReceivedMessageId = any2EvmMessage.messageId; // fetch the messageId\n    s_lastReceivedText = abi.decode(any2EvmMessage.data, (string)); // abi-decoding of the sent text\n\n    emit MessageReceived(\n      any2EvmMessage.messageId,\n      any2EvmMessage.sourceChainSelector, // fetch the source chain identifier (aka selector)\n      abi.decode(any2EvmMessage.sender, (address)), // abi-decoding of the sender address,\n      abi.decode(any2EvmMessage.data, (string))\n    );\n  }\n\n  /// @notice Fetches the details of the last received message.\n  /// @return messageId The ID of the last received message.\n  /// @return text The last received text.\n  function getLastReceivedMessageDetails() external view returns (bytes32 messageId, string memory text) {\n    return (s_lastReceivedMessageId, s_lastReceivedText);\n  }\n}\n"
    },
    "src/ccip/LinkTokenHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport { BurnMintERC677 } from '@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/BurnMintERC677.sol';\n\n/// @title BurnMintERC677Helper\n/// @notice This contract extends the functionality of the BurnMintERC677 token contract to include a `drip` function that mints one full token to a specified address.\n/// @dev Inherits from the BurnMintERC677 contract and sets the token name, symbol, decimals, and initial supply in the constructor.\ncontract LinkTokenHelper is BurnMintERC677 {\n  /**\n   * @notice Constructor to initialize the BurnMintERC677Helper contract with a name and symbol.\n   * @dev Calls the parent constructor of BurnMintERC677 with fixed decimals (18) and initial supply (0).\n   * @param name - The name of the token.\n   * @param symbol - The symbol of the token.\n   */\n  constructor(string memory name, string memory symbol) BurnMintERC677(name, symbol, 18, 0) {}\n\n  /**\n   * @notice Mints one full token (1e18) to the specified address.\n   * @dev Calls the internal `_mint` function from the BurnMintERC677 contract.\n   * @param to - The address to receive the minted token.\n   */\n  function drip(address to) external {\n    _mint(to, 1e18);\n  }\n}\n"
    },
    "src/ClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport './interface/IClaimIssuer.sol';\nimport './Identity.sol';\n\ncontract ClaimIssuer is IClaimIssuer, Identity {\n  mapping(bytes => bool) public revokedClaims;\n\n  // solhint-disable-next-line no-empty-blocks\n  constructor(address initialManagementKey, address _idFactory) Identity(initialManagementKey, false, _idFactory) {}\n\n  /**\n   *  @dev See {IClaimIssuer-revokeClaimBySignature}.\n   */\n  function revokeClaimBySignature(bytes calldata signature) external override delegatedOnly onlyManager {\n    require(!revokedClaims[signature], 'Conflict: Claim already revoked');\n\n    revokedClaims[signature] = true;\n\n    emit ClaimRevoked(signature);\n  }\n\n  /**\n   *  @dev See {IClaimIssuer-revokeClaim}.\n   */\n  function revokeClaim(bytes32 _claimId, address _identity) external override delegatedOnly onlyManager returns (bool) {\n    uint256 foundClaimTopic;\n    uint256 scheme;\n    address issuer;\n    bytes memory sig;\n    bytes memory data;\n\n    (foundClaimTopic, scheme, issuer, sig, data, ) = Identity(_identity).getClaim(_claimId);\n\n    require(!revokedClaims[sig], 'Conflict: Claim already revoked');\n\n    revokedClaims[sig] = true;\n    emit ClaimRevoked(sig);\n    return true;\n  }\n\n  /**\n   *  @dev See {IClaimIssuer-isClaimValid}.\n   */\n  function isClaimValid(\n    IIdentity _identity,\n    uint256 claimTopic,\n    bytes memory sig,\n    bytes memory data\n  ) public view override(Identity, IClaimIssuer) returns (bool claimValid) {\n    bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n    // Use abi.encodePacked to concatenate the message prefix and the message to sign.\n    bytes32 prefixedHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', dataHash));\n\n    // Recover address of data signer\n    address recovered = getRecoveredAddress(sig, prefixedHash);\n\n    // Take hash of recovered address\n    bytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n    // Does the trusted identifier have they key which signed the user's claim?\n    //  && (isClaimRevoked(_claimId) == false)\n    if (keyHasPurpose(hashedAddr, 3) && (isClaimRevoked(sig) == false)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   *  @dev See {IClaimIssuer-isClaimRevoked}.\n   */\n  function isClaimRevoked(bytes memory _sig) public view override returns (bool) {\n    if (revokedClaims[_sig]) {\n      return true;\n    }\n\n    return false;\n  }\n}\n"
    },
    "src/factory/IdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport '../proxy/IdentityProxy.sol';\nimport './IIdFactory.sol';\nimport '../interface/IERC734.sol';\nimport { CrossChainBridge } from '../bridge/Bridge.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport { Address } from '@openzeppelin/contracts/utils/Address.sol';\nimport '../IAccessRegistry.sol';\n/// @notice REMOVE in prod\nimport 'hardhat/console.sol';\n\ncontract IdFactory is IIdFactory, Ownable, IAccessRegistry {\n  mapping(address => bool) private _tokenFactories;\n\n  // address of the _implementationAuthority contract making the link to the implementation contract\n  address private immutable _implementationAuthority;\n\n  // as it is not possible to deploy 2 times the same contract address, this mapping allows us to check which\n  // salt is taken and which is not\n  mapping(string => bool) private _saltTaken;\n\n  // ONCHAINID of the wallet owner\n  mapping(address => address) private _userIdentity;\n  mapping(address => address) private _identityWallet;\n\n  // wallets currently linked to an ONCHAINID\n  mapping(address => address[]) private _wallets;\n\n  // ONCHAINID of the token\n  mapping(address => address) private _tokenIdentity;\n\n  // token linked to an ONCHAINID\n  mapping(address => address) private _tokenAddress;\n\n  // flag to check if the contract is on the home chain\n  bool public _isHomeChain;\n\n  // DetinationChainSelectors and Receivers address (Receiver is the Bridge contract on the destination chain)\n  mapping(uint64 => address) public destinationChainSelectorToReceiver;\n  mapping(uint64 => address) public destinationChainSelectorToGateway;\n  uint64[] private chainSelectors;\n\n  // CrossChainBridge address\n  address public bridge;\n\n  // Map to store allowedContracts\n  mapping(address => bool) public isAllowedContract;\n\n  // Map to store onlyManagers\n  mapping(address => bool) public isManager;\n\n  // Map to store created identities\n  mapping(address => bool) public isCreatedIdentity;\n\n  // Define the enum\n  enum AccessAddressTypes {\n    CONTRACT,\n    MANAGER\n  }\n\n  modifier onlyAllowedSender() {\n    require(\n      isAllowedContract[msg.sender] == true || isManager[msg.sender] == true,\n      'Permissions: Sender is not a allowed'\n    );\n    _;\n  }\n\n  modifier onlyAllowedContract() {\n    require(isAllowedContract[msg.sender] == true, 'Permissions: Sender is not a allowed contract');\n    _;\n  }\n\n  modifier onlyManager() {\n    require(isManager[msg.sender] == true, 'Permissions: Sender is not a Manager');\n    _;\n  }\n\n  event AllowedAddress(address indexed _address, uint64 indexed _type, bool indexed _status);\n\n  // setting\n  constructor(address _owner, address implementationAuthority, bool isHomeChain) {\n    require(implementationAuthority != address(0), 'invalid argument - zero address');\n    require(_owner != address(0), 'invalid argument - zero address');\n\n    _implementationAuthority = implementationAuthority;\n    _isHomeChain = isHomeChain;\n    isManager[_owner] = true;\n    _transferOwnership(_owner);\n    emit AllowedAddress(_owner, uint64(AccessAddressTypes.MANAGER), true);\n  }\n\n  /**\n   *  @dev See {IdFactory-addTokenFactory}.\n   */\n  function addTokenFactory(address _factory) external override onlyOwner {\n    require(_factory != address(0), 'invalid argument - zero address');\n    require(!isTokenFactory(_factory), 'already a factory');\n    _tokenFactories[_factory] = true;\n    emit TokenFactoryAdded(_factory);\n  }\n\n  /**\n   *  @dev See {IdFactory-removeTokenFactory}.\n   */\n  function removeTokenFactory(address _factory) external override onlyOwner {\n    require(_factory != address(0), 'invalid argument - zero address');\n    require(isTokenFactory(_factory), 'not a factory');\n    _tokenFactories[_factory] = false;\n    emit TokenFactoryRemoved(_factory);\n  }\n\n  /**\n   *  @dev See {IdFactory-createIdentity}.\n   */\n  function createIdentity(\n    address _wallet,\n    string memory _salt\n  ) external override onlyAllowedSender returns (address identity) {\n    require(_wallet != address(0), 'invalid argument - zero address');\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\n    require(!_saltTaken[_salt], 'salt already taken');\n    require(_userIdentity[_wallet] == address(0), 'wallet already linked to an identity');\n    identity = _deployIdentity(_salt, _implementationAuthority, _wallet);\n    _saltTaken[_salt] = true;\n    _userIdentity[_wallet] = identity;\n    _identityWallet[identity] = _wallet;\n    _wallets[identity].push(_wallet);\n    emit WalletLinked(_wallet, identity);\n\n    isCreatedIdentity[identity] = true;\n    if (_isHomeChain == true) {\n      bytes32[] memory _keys;\n      _bridgeCreateIdentity(_wallet, _salt, _keys);\n    }\n    return identity;\n  }\n\n  /**\n   *  @dev See {IdFactory-createIdentityWithManagementKeys}.\n   */\n  function createIdentityWithManagementKeys(\n    address _wallet,\n    string memory _salt,\n    bytes32[] memory _managementKeys\n  ) external override onlyAllowedSender returns (address) {\n    require(_wallet != address(0), 'invalid argument - zero address');\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\n    string memory oidSalt = string.concat('OID', _salt);\n    require(!_saltTaken[oidSalt], 'salt already taken');\n    require(_userIdentity[_wallet] == address(0), 'wallet already linked to an identity');\n    require(_managementKeys.length > 0, 'invalid argument - empty list of keys');\n\n    address identity = _deployIdentity(oidSalt, _implementationAuthority, address(this));\n\n    _saltTaken[oidSalt] = true;\n    _userIdentity[_wallet] = identity;\n    _identityWallet[identity] = _wallet;\n    _wallets[identity].push(_wallet);\n    isCreatedIdentity[identity] = true;\n    if (_isHomeChain == true) {\n      _bridgeCreateIdentity(_wallet, _salt, _managementKeys);\n    }\n    for (uint i = 0; i < _managementKeys.length; i++) {\n      require(\n        _managementKeys[i] != keccak256(abi.encode(_wallet)),\n        'invalid argument - wallet is also listed in management keys'\n      );\n      IERC734(identity).addKey(_managementKeys[i], 1, 1);\n    }\n\n    IERC734(identity).removeKey(keccak256(abi.encode(address(this))), 1);\n\n    emit WalletLinked(_wallet, identity);\n\n    return identity;\n  }\n\n  /**\n   *  @dev See {IdFactory-createTokenIdentity}.\n   */\n  function createTokenIdentity(\n    address _token,\n    address _tokenOwner,\n    string memory _salt\n  ) external override returns (address) {\n    require(isTokenFactory(msg.sender) || msg.sender == owner(), 'only Factory or owner can call');\n    require(_token != address(0), 'invalid argument - zero address');\n    require(_tokenOwner != address(0), 'invalid argument - zero address');\n    require(keccak256(abi.encode(_salt)) != keccak256(abi.encode('')), 'invalid argument - empty string');\n    string memory tokenIdSalt = string.concat('Token', _salt);\n    require(!_saltTaken[tokenIdSalt], 'salt already taken');\n    require(_tokenIdentity[_token] == address(0), 'token already linked to an identity');\n    address identity = _deployIdentity(tokenIdSalt, _implementationAuthority, _tokenOwner);\n    _saltTaken[tokenIdSalt] = true;\n    _tokenIdentity[_token] = identity;\n    _tokenAddress[identity] = _token;\n    emit TokenLinked(_token, identity);\n    return identity;\n  }\n\n  /**\n   *  @dev See {IdFactory-linkWallet}.\n   */\n  function linkWallet(address _newWallet) external override {\n    require(_newWallet != address(0), 'invalid argument - zero address');\n    require(_userIdentity[msg.sender] != address(0), 'wallet not linked to an identity contract');\n    require(_userIdentity[_newWallet] == address(0), 'new wallet already linked');\n    require(_tokenIdentity[_newWallet] == address(0), 'invalid argument - token address');\n    address identity = _userIdentity[msg.sender];\n    require(_wallets[identity].length < 101, 'max amount of wallets per ID exceeded');\n    _userIdentity[_newWallet] = identity;\n    _wallets[identity].push(_newWallet);\n    emit WalletLinked(_newWallet, identity);\n  }\n\n  /**\n   *  @dev See {IdFactory-unlinkWallet}.\n   */\n  function unlinkWallet(address _oldWallet) external override {\n    require(_oldWallet != address(0), 'invalid argument - zero address');\n    require(_oldWallet != msg.sender, 'cannot be called on sender address');\n    require(_userIdentity[msg.sender] == _userIdentity[_oldWallet], 'only a linked wallet can unlink');\n    address _identity = _userIdentity[_oldWallet];\n    delete _userIdentity[_oldWallet];\n    uint256 length = _wallets[_identity].length;\n    for (uint256 i = 0; i < length; i++) {\n      if (_wallets[_identity][i] == _oldWallet) {\n        _wallets[_identity][i] = _wallets[_identity][length - 1];\n        _wallets[_identity].pop();\n        break;\n      }\n    }\n    emit WalletUnlinked(_oldWallet, _identity);\n  }\n\n  /**\n   *  @dev See {IdFactory-addReceiver}.\n   */\n\n  function addReceiver(uint64 _chainSelector, address _receiver, address _gateway) external override onlyOwner {\n    require(_receiver != address(0), 'invalid argument - zero address');\n    require(destinationChainSelectorToReceiver[_chainSelector] == address(0), 'receiver already added');\n    require(destinationChainSelectorToGateway[_chainSelector] == address(0), 'gateway already added');\n\n    destinationChainSelectorToReceiver[_chainSelector] = _receiver;\n    destinationChainSelectorToGateway[_chainSelector] = _gateway;\n\n    chainSelectors.push(_chainSelector);\n    emit ReceiverAdded(_chainSelector, _receiver, _gateway);\n  }\n\n  /**\n   *  @dev See {IdFactory-removeReceiver}.\n   */\n\n  function removeReceiver(uint64 _chainSelector) external override onlyOwner {\n    require(destinationChainSelectorToReceiver[_chainSelector] != address(0), 'receiver not added');\n    delete destinationChainSelectorToReceiver[_chainSelector];\n    delete destinationChainSelectorToGateway[_chainSelector];\n\n    uint256 length = chainSelectors.length;\n    for (uint256 i = 0; i < length; i++) {\n      if (chainSelectors[i] == _chainSelector) {\n        chainSelectors[i] = chainSelectors[length - 1];\n        chainSelectors.pop();\n        break;\n      }\n    }\n    emit ReceiverRemoved(_chainSelector);\n  }\n\n  /**\n   *  @dev See {IdFactory-getChainSelectors}.\n   */\n\n  function getChainSelectors() external view override returns (uint64[] memory) {\n    return chainSelectors;\n  }\n\n  /**\n   *  @dev See {IdFactory-getReceiver}.\n   */\n\n  function getReceiver(uint64 _chainSelector) external view override returns (address) {\n    return destinationChainSelectorToReceiver[_chainSelector];\n  }\n\n  function getGateway(uint64 _chainSelector) external view returns (address) {\n    return destinationChainSelectorToGateway[_chainSelector];\n  }\n\n  /**\n   *  @dev See {IdFactory-getReceivers}.\n   */\n\n  function getReceivers() external view override returns (address[] memory) {\n    address[] memory receivers = new address[](chainSelectors.length);\n    for (uint256 i = 0; i < chainSelectors.length; i++) {\n      receivers[i] = destinationChainSelectorToReceiver[chainSelectors[i]];\n    }\n    return receivers;\n  }\n\n  /**\n   *  @dev See {IdFactory-getIdentity}.\n   */\n  function getIdentity(address _wallet) public view override returns (address) {\n    if (_tokenIdentity[_wallet] != address(0)) {\n      return _tokenIdentity[_wallet];\n    } else {\n      return _userIdentity[_wallet];\n    }\n  }\n\n  /**\n   *  @dev See {IdFactory-isSaltTaken}.\n   */\n  function isSaltTaken(string calldata _salt) external view override returns (bool) {\n    return _saltTaken[_salt];\n  }\n\n  /**\n   *  @dev See {IdFactory-getWallets}.\n   */\n  function getWallets(address _identity) external view override returns (address[] memory) {\n    return _wallets[_identity];\n  }\n\n  /**\n   *  @dev See {IdFactory-getToken}.\n   */\n  function getToken(address _identity) external view override returns (address) {\n    return _tokenAddress[_identity];\n  }\n\n  /**\n   *  @dev See {IdFactory-isTokenFactory}.\n   */\n  function isTokenFactory(address _factory) public view override returns (bool) {\n    return _tokenFactories[_factory];\n  }\n\n  /**\n   *  @dev See {IdFactory-implementationAuthority}.\n   */\n  function implementationAuthority() public view override returns (address) {\n    return _implementationAuthority;\n  }\n\n  /**\n   *\n   * @param _bridge the address of the bridge contract\n   */\n  function setBridge(address _bridge) external onlyOwner {\n    require(_bridge != address(0), 'invalid argument - zero address');\n    bridge = _bridge;\n  }\n\n  /**\n   *  @dev get bridge address\n   */\n  function getBridge() external view returns (address) {\n    return bridge;\n  }\n\n  // deploy function with create2 opcode call\n  // returns the address of the contract created\n  function _deploy(string memory salt, bytes memory bytecode) private returns (address) {\n    bytes32 saltBytes = bytes32(keccak256(abi.encodePacked(salt)));\n    address addr;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let encoded_data := add(0x20, bytecode) // load initialization code.\n      let encoded_size := mload(bytecode) // load init code's length.\n      addr := create2(0, encoded_data, encoded_size, saltBytes)\n      if iszero(extcodesize(addr)) {\n        revert(0, 0)\n      }\n    }\n    emit Deployed(addr);\n    return addr;\n  }\n\n  // function used to deploy an identity using CREATE2\n  function _deployIdentity(\n    string memory _salt,\n    address implementationAuthority,\n    address _wallet\n  ) private returns (address) {\n    bytes memory _code = type(IdentityProxy).creationCode;\n    bytes memory _constructData = abi.encode(implementationAuthority, _wallet, address(this));\n    bytes memory bytecode = abi.encodePacked(_code, _constructData);\n    return _deploy(_salt, bytecode);\n  }\n\n  function _bridgeCreateIdentity(\n    address _wallet,\n    string memory oidSalt,\n    bytes32[] memory managementKeys // uint256 signatureExpiry, // bytes calldata signature\n  ) internal {\n    for (uint256 i = 0; i < chainSelectors.length; i++) {\n      CrossChainBridge bridgeContract = CrossChainBridge(payable(bridge));\n      bridgeContract.sendCreateIdentity(\n        chainSelectors[i],\n        destinationChainSelectorToReceiver[chainSelectors[i]],\n        destinationChainSelectorToGateway[chainSelectors[i]],\n        _wallet,\n        oidSalt,\n        managementKeys\n        // signatureExpiry,\n        // signature\n      );\n    }\n  }\n\n  // Function to set allowed contracts\n  function setAllowedContract(address _contract, bool _status) external onlyManager {\n    if (_status == true) {\n      require(Address.isContract(_contract), 'Permissions: Address is not a contract');\n    }\n    isAllowedContract[_contract] = _status;\n\n    emit AllowedAddress(_contract, uint64(AccessAddressTypes.CONTRACT), _status);\n  }\n\n  // Function to set manager status\n  function setManager(address _manager, bool _status) external onlyManager {\n    isManager[_manager] = _status;\n\n    emit AllowedAddress(_manager, uint64(AccessAddressTypes.MANAGER), _status);\n  }\n\n  function identityIsCreated(address _identity) external view returns (bool) {\n    return isCreatedIdentity[_identity];\n  }\n\n  function addedKey(bool isTrue, bytes32 _key, uint256 _purpose, uint256 _type) public {\n    require(isCreatedIdentity[msg.sender] == true, 'Invalid Identity');\n    require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), 'Permissions: Only Identity can Call');\n    emit AddedKey(_identityWallet[msg.sender], _key, _purpose, _type);\n    IERC734(msg.sender).isComingFromIdentity(false);\n  }\n\n  function addedClaim(\n    bool isTrue,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n  ) public {\n    require(isCreatedIdentity[msg.sender] == true, 'Invalid Identity');\n    require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), 'Permissions: Only Identity can Call');\n    emit AddedClaim(_identityWallet[msg.sender], _topic, _scheme, _issuer, _signature, _data, _uri);\n    IERC734(msg.sender).isComingFromIdentity(false);\n  }\n\n\n    function removedKey(\n      bool isTrue,\n      bytes32 _key,\n      uint256 _purpose,\n      uint256 _type\n      ) public {\n        \n      require(isCreatedIdentity[msg.sender]== true, \"Invalid Identity\");\n      require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), \"Permissions: Only Identity can Call\");\n      emit RemovedKey(_identityWallet[msg.sender], _key, _purpose, _type);\n      IERC734(msg.sender).isComingFromIdentity(false);\n\n    }\n\n    function removedClaim(\n      bool isTrue,\n      bytes32 _claimId,\n      uint256 _topic,\n      uint256 _scheme,\n      address _issuer,\n      bytes memory _signature,\n      bytes memory _data,\n      string memory _uri\n    ) public {\n    \n      require(isCreatedIdentity[msg.sender]== true, \"Invalid Identity\");\n      require(isTrue == IERC734(msg.sender).isComingFromIdentity(true), \"Permissions: Only Identity can Call\");\n      emit RemovedClaim(_identityWallet[msg.sender], _claimId,_topic, _scheme, _issuer, _signature, _data, _uri);\n      IERC734(msg.sender).isComingFromIdentity(false);\n\n  }\n\n\n  // For fireblocks integeration\n  // from IAccessRegistry.sol\n  function hasAccess(address account, address caller, bytes calldata data) external view returns (bool) {\n    require(_userIdentity[account] != address(0), \"identity doesn't exists\");\n\n    // TODO: check claims\n    return true;\n  }\n}\n"
    },
    "src/factory/IIdFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\ninterface IIdFactory {\n  /// events\n\n\t// AddedKey to notify everyone when key added without listening to long list of identity addresses\n\tevent AddedKey(address user, bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n  // RemovedKey to notify everyone when key removed without listening to long list of identity addresses\n\tevent RemovedKey(address user, bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\n\t// AddedClaim to notify everyone when claim added without listening to long list of identity addresses\n\tevent AddedClaim(\n    address indexed user,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\tevent RemovedClaim(\n    address user,\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n  // event emitted whenever a single contract is deployed by the factory\n  event Deployed(address indexed _addr);\n\n  // event emitted when a wallet is linked to an ONCHAINID contract\n  event WalletLinked(address indexed wallet, address indexed identity);\n\n  // event emitted when a token is linked to an ONCHAINID contract\n  event TokenLinked(address indexed token, address indexed identity);\n\n  // event emitted when a wallet is unlinked from an ONCHAINID contract\n  event WalletUnlinked(address indexed wallet, address indexed identity);\n\n  // event emitted when an address is registered on the factory as a Token\n  // factory address, granting this address the privilege to issue\n  // Onchain identities for tokens\n  event TokenFactoryAdded(address indexed factory);\n\n  // event emitted when a previously recorded token factory address is removed\n  event TokenFactoryRemoved(address indexed factory);\n\n  // event emitted when a receiver is added for a chainSelector\n  event ReceiverAdded(uint64 chainSelector, address receiver, address gateway);\n\n  // event emitted when a receiver is removed for a chainSelector\n  event ReceiverRemoved(uint64 chainSelector);\n\n  /// functions\n\n  /**\n   *  @dev function used to create a new Identity proxy from the factory\n   *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n   *  @param _salt the salt used by create2 to issue the contract\n   *  requires a new salt for each deployment\n   *  _wallet cannot be linked to another ONCHAINID\n   *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n   *  of the function, including calls to oracles for multichain\n   *  deployment security (avoid identity theft), defining payment requirements, etc.\n   */\n  function createIdentity(address _wallet, string memory _salt) external returns (address);\n\n  /**\n   *  @dev function used to create a new Identity proxy from the factory, setting the wallet and listed keys as\n   * MANAGEMENT keys.\n   *  @param _wallet the wallet address of the primary owner of this ONCHAINID contract\n   *  @param _salt the salt used by create2 to issue the contract\n   *  @param _managementKeys A list of keys hash (keccak256(abiEncoded())) to add as MANAGEMENT keys.\n   *  requires a new salt for each deployment\n   *  _wallet cannot be linked to another ONCHAINID\n   *  only Owner can call => Owner is supposed to be a smart contract, managing the accessibility\n   *  of the function, including calls to oracles for multichain\n   *  deployment security (avoid identity theft), defining payment requirements, etc.\n   */\n  function createIdentityWithManagementKeys(\n    address _wallet,\n    string memory _salt,\n    bytes32[] memory _managementKeys\n  ) external returns (address);\n\n  /**\n   *  @dev function used to create a new Token Identity proxy from the factory\n   *  @param _token the address of the token contract\n   *  @param _tokenOwner the owner address of the token\n   *  @param _salt the salt used by create2 to issue the contract\n   *  requires a new salt for each deployment\n   *  _token cannot be linked to another ONCHAINID\n   *  only Token factory or owner can call (owner should only use its privilege\n   *  for tokens not issued by a Token factory onchain\n   */\n  function createTokenIdentity(address _token, address _tokenOwner, string memory _salt) external returns (address);\n\n  /**\n   * @dev function used to update bridge contract address\n   * @param _bridge the address of the bridge contract\n   * can be called only by Owner\n   */\n\n  function setBridge(address _bridge) external;\n\n  /**\n   *  @dev function used to link a new wallet to an existing identity\n   *  @param _newWallet the address of the wallet to link\n   *  requires msg.sender to be linked to an existing onchainid\n   *  the _newWallet will be linked to the same OID contract as msg.sender\n   *  _newWallet cannot be linked to an OID yet\n   *  _newWallet cannot be address 0\n   *  cannot link more than 100 wallets to an OID, for gas consumption reason\n   */\n  function linkWallet(address _newWallet) external;\n\n  /**\n   *  @dev function used to unlink a wallet from an existing identity\n   *  @param _oldWallet the address of the wallet to unlink\n   *  requires msg.sender to be linked to the same onchainid as _oldWallet\n   *  msg.sender cannot be _oldWallet to keep at least 1 wallet linked to any OID\n   *  _oldWallet cannot be address 0\n   */\n  function unlinkWallet(address _oldWallet) external;\n\n  /**\n   *  @dev function used to register an address as a token factory\n   *  @param _factory the address of the token factory\n   *  can be called only by Owner\n   *  _factory cannot be registered yet\n   *  once the factory has been registered it can deploy token identities\n   */\n  function addTokenFactory(address _factory) external;\n\n  /**\n   *  @dev function used to unregister an address previously registered as a token factory\n   *  @param _factory the address of the token factory\n   *  can be called only by Owner\n   *  _factory has to be registered previously\n   *  once the factory has been unregistered it cannot deploy token identities anymore\n   */\n  function removeTokenFactory(address _factory) external;\n\n  /**\n   *  @dev function used to add a receiver for a chainSelector\n   *  @param _chainSelector the chainSelector for which the receiver is added\n   *  @param _receiver the address of the receiver\n   *  @param _gateway the address of the gateway\n   *  can be called only by Owner\n   *  _receiver cannot be registered yet\n   *  once the receiver has been registered it can receive messages from the chainSelector\n   */\n  function addReceiver(uint64 _chainSelector, address _receiver, address _gateway) external;\n\n  /**\n   *  @dev function used to remove a receiver for a chainSelector\n   *  @param _chainSelector the chainSelector for which the receiver is removed\n   *  can be called only by Owner\n   *  _receiver has to be registered previously\n   *  once the receiver has been removed it cannot receive messages from the chainSelector anymore\n   */\n  function removeReceiver(uint64 _chainSelector) external;\n\n  /**\n   *  @dev getter for OID contract corresponding to a wallet/token\n   *  @param _wallet the wallet/token address\n   */\n  function getIdentity(address _wallet) external view returns (address);\n\n  /**\n   *  @dev getter to fetch the array of wallets linked to an OID contract\n   *  @param _identity the address of the OID contract\n   *  returns an array of addresses linked to the OID\n   */\n  function getWallets(address _identity) external view returns (address[] memory);\n\n  /**\n   *  @dev getter to fetch the token address linked to an OID contract\n   *  @param _identity the address of the OID contract\n   *  returns the address linked to the OID\n   */\n  function getToken(address _identity) external view returns (address);\n\n  /**\n   *  @dev getter to know if an address is registered as token factory or not\n   *  @param _factory the address of the factory\n   *  returns true if the address corresponds to a registered factory\n   */\n  function isTokenFactory(address _factory) external view returns (bool);\n\n  /**\n   *  @dev getter to know if a salt is taken for the create2 deployment\n   *  @param _salt the salt used for deployment\n   */\n  function isSaltTaken(string calldata _salt) external view returns (bool);\n\n  /**\n   * @dev getter for the implementation authority used by this factory.\n   */\n  function implementationAuthority() external view returns (address);\n\n  /**\n   * @dev getter for the receiver of a chainSelector\n   * @param _chainSelector the chainSelector for which the receiver is fetched\n   */\n  function getReceiver(uint64 _chainSelector) external view returns (address);\n\n  /**\n   * @dev getter for the list of chainSelectors\n   */\n  function getChainSelectors() external view returns (uint64[] memory);\n\n  /**\n   * @dev getter for the list of receivers\n   */\n  function getReceivers() external view returns (address[] memory);\n\n  /**\n   * @dev getter for the bridge contract address\n   */\n  function bridge() external view returns (address);\n\n  /**\n   * @dev getter for the created Identites\n   */\n  function identityIsCreated(address identity) external view returns (bool);\n\n  function addedKey(\n    bool _isTrue,\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n    ) external;\n\n    function addedClaim(\n    bool _isTrue,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n    ) external;\n\n\n  function removedKey(\n    bool _isTrue,\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n    ) external;\n\n    function removedClaim(\n    bool _isTrue,\n    bytes32 _claimId,\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n    ) external;\n\n\n}\n"
    },
    "src/factory/IssuerFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\n\nimport \"../ClaimIssuer.sol\";\n\n\ncontract IssuerFactory {\n    event Deployed(address addr, bytes32 salt);\n\n    mapping(bytes32 => bool) private _saltUsed;\n\n    function _deploy(string memory salt, bytes memory bytecode) public returns (address) {\n        bytes32 saltBytes = keccak256(abi.encodePacked(salt));\n        require(!_saltUsed[saltBytes], \"Salt already used\");\n\n        address addr;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let encoded_data := add(0x20, bytecode) // load initialization code.\n            let encoded_size := mload(bytecode) // load init code's length.\n            addr := create2(0, encoded_data, encoded_size, saltBytes)\n            if iszero(extcodesize(addr)) {\n                revert(0, 0)\n            }\n        }\n        emit Deployed(addr, saltBytes);\n        _saltUsed[saltBytes] = true;\n        return addr;\n    }\n\n    function deployClaimIssuer(\n        string memory salt,\n        address implementationAuthority,\n        address wallet\n    ) public returns (address) {\n        bytes memory code = type(ClaimIssuer).creationCode;\n        bytes memory constructData = abi.encode(implementationAuthority, wallet);\n        bytes memory bytecode = abi.encodePacked(code, constructData);\n        return _deploy(salt, bytecode);\n    }\n\n    function isSaltUsed(string memory salt) public view returns (bool) {\n        bytes32 saltBytes = keccak256(abi.encodePacked(salt));\n        return _saltUsed[saltBytes];\n    }\n}"
    },
    "src/gated/xAuthGated.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport '../interface/IIdentity.sol';\nimport '../factory/IIdFactory.sol';\nimport '../interface/IClaimIssuer.sol';\n\nuint256 constant CLAIM_BASIC_IDENTITY = 10101000100001;\nuint256 constant CLAIM_FINANCIAL = 10101020100001;\n\ncontract xAuthGated {\n  IIdFactory public identityFactory;\n  IClaimIssuer private claimIssuer;\n\n  address private owner;\n\n  constructor(address _idFactory, address _claimIssuer) {\n    identityFactory = IIdFactory(_idFactory);\n    claimIssuer = IClaimIssuer(_claimIssuer);\n  }\n\n  /**\n   * Usage example:\n   *\n   * function mint(to) requireClaim(msg.sender, CLAIM_FINANCIAL)\n   *\n   * @param claim claim required\n   */\n\n  modifier requireClaim(address wallet, uint256 claim) {\n    _validateClaim(wallet, claim);\n    _;\n  }\n\n  function _validateClaim(address wallet, uint256 requiredTopic) private view {\n    address identityAddr = identityFactory.getIdentity(wallet);\n    require(identityAddr != address(0), 'no identity contract found');\n\n    bytes32 claimId = keccak256(abi.encode(claimIssuer, requiredTopic));\n\n    (uint256 topic, , , bytes memory signature, bytes memory data, ) = IIdentity(identityAddr).getClaim(claimId);\n\n    bool isValid = claimIssuer.isClaimValid(IIdentity(identityAddr), topic, signature, data);\n    require(isValid, 'Claim is not valid or unauthorized');\n  }\n}\n"
    },
    "src/gateway/Gateway.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport '@openzeppelin/contracts/utils/cryptography/ECDSA.sol';\nimport '../factory/IdFactory.sol';\n// import '../bridge/Bridge.sol';\n\nusing ECDSA for bytes32;\n\n/// A required parameter was set to the Zero address.\nerror ZeroAddress();\n/// The maximum number of signers was reached at deployment.\nerror TooManySigners();\n/// The signed attempted to add was already approved.\nerror SignerAlreadyApproved(address signer);\n/// The signed attempted to remove was not approved.\nerror SignerAlreadyNotApproved(address signer);\n/// A requested ONCHAINID deployment was requested without a valid signature while the Gateway requires one.\nerror UnsignedDeployment();\n/// A requested ONCHAINID deployment was requested and signer by a non approved signer.\nerror UnapprovedSigner(address signer);\n/// A requested ONCHAINID deployment was requested with a signature revoked.\nerror RevokedSignature(bytes signature);\n/// A requested ONCHAINID deployment was requested with a signature that expired.\nerror ExpiredSignature(bytes signature);\n/// Attempted to revoke a signature that was already revoked.\nerror SignatureAlreadyRevoked(bytes signature);\n/// Attempted to approve a signature that was not revoked.\nerror SignatureNotRevoked(bytes signature);\n\ncontract Gateway is Ownable {\n  IdFactory public idFactory;\n  mapping(address => bool) public approvedSigners;\n  mapping(bytes => bool) public revokedSignatures;\n\n  event SignerApproved(address indexed signer);\n  event SignerRevoked(address indexed signer);\n  event SignatureRevoked(bytes indexed signature);\n  event SignatureApproved(bytes indexed signature);\n\n  /**\n   *  @dev Constructor for the ONCHAINID Factory Gateway.\n   *  @param idFactoryAddress the address of the factory to operate (the Gateway must be owner of the Factory).\n   */\n  constructor(address idFactoryAddress, address[] memory signersToApprove) Ownable() {\n    if (idFactoryAddress == address(0)) {\n      revert ZeroAddress();\n    }\n    if (signersToApprove.length > 10) {\n      revert TooManySigners();\n    }\n\n    for (uint i = 0; i < signersToApprove.length; i++) {\n      approvedSigners[signersToApprove[i]] = true;\n    }\n\n    idFactory = IdFactory(idFactoryAddress);\n  }\n\n  /**\n   *  @dev Approve a signer to sign ONCHAINID deployments. If the Gateway is setup to require signature, only\n   *  deployments requested with a valid signature from an approved signer will be accepted.\n   *  If the gateway does not require a signature,\n   *  @param signer the signer address to approve.\n   */\n  function approveSigner(address signer) external onlyOwner {\n    if (signer == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (approvedSigners[signer]) {\n      revert SignerAlreadyApproved(signer);\n    }\n\n    approvedSigners[signer] = true;\n\n    emit SignerApproved(signer);\n  }\n\n  /**\n   *  @dev Revoke a signer to sign ONCHAINID deployments.\n   *  @param signer the signer address to revoke.\n   */\n  function revokeSigner(address signer) external onlyOwner {\n    if (signer == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (!approvedSigners[signer]) {\n      revert SignerAlreadyNotApproved(signer);\n    }\n\n    delete approvedSigners[signer];\n\n    emit SignerRevoked(signer);\n  }\n\n  function deployIdentity(\n    address identityOwner,\n    string memory salt,\n    bytes32[] calldata managementKeys\n  ) public returns (address) {\n    if (managementKeys.length == 0) {\n      return deployIdentityWithSalt(identityOwner, salt);\n    } else {\n      return deployIdentityWithSaltAndManagementKeys(identityOwner, salt, managementKeys);\n    }\n  }\n\n  /**\n   *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\n   *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt.\n   *  @param identityOwner the address to set as a management key.\n   *  @param salt to use for the deployment.\n   */\n  function deployIdentityWithSalt(address identityOwner, string memory salt) public returns (address) {\n    if (identityOwner == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (!approvedSigners[msg.sender]) {\n      revert UnapprovedSigner(msg.sender);\n    }\n\n    return idFactory.createIdentity(identityOwner, salt);\n  }\n\n  /**\n   *  @dev Deploy an ONCHAINID using a factory. The operation must be signed by\n   *  an approved public key. This method allow to deploy an ONCHAINID using a custom salt and a custom list of\n   *  management keys. Note that the identity Owner address won't be added as a management keys, if this is desired,\n   *  the key hash must be listed in the managementKeys array.\n   *  @param identityOwner the address to set as a management key.\n   *  @param salt to use for the deployment.\n   *  @param managementKeys the list of management keys to add to the ONCHAINID.\n   */\n  function deployIdentityWithSaltAndManagementKeys(\n    address identityOwner,\n    string memory salt,\n    bytes32[] calldata managementKeys\n  ) public returns (address) {\n    if (identityOwner == address(0)) {\n      revert ZeroAddress();\n    }\n\n    if (!approvedSigners[msg.sender]) {\n      revert UnapprovedSigner(msg.sender);\n    }\n\n    address identity = idFactory.createIdentityWithManagementKeys(identityOwner, salt, managementKeys);\n\n    // bool isHomeChain = idFactory._isHomeChain();\n\n    // if (isHomeChain) {\n    //   address bridgeAddress = idFactory.getBridge();\n    //   // Explicit conversion to payable address and then to CrossChainBridge\n    //   CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n    //   // Get Destination Chain Selectors and their receivers\n    //   address[] memory receivers = idFactory.getReceivers();\n    //   uint64[] memory chainSelectors = idFactory.getChainSelectors();\n    // Send the CreateIdentity message to the bridge\n    //   for (uint i = 0; i < receivers.length; i++) {\n    //     if (receivers[i] != address(bridge)) {\n    //       bridge.sendCreateIdentity(\n    //         chainSelectors[i],\n    //         receivers[i],\n    //         address(this),\n    //         identityOwner,\n    //         salt,\n    //         managementKeys,\n    //         signatureExpiry,\n    //         signature\n    //       );\n    //     }\n    //   }\n    // }\n\n    return identity;\n  }\n\n  /**\n   *  @dev Deploy an ONCHAINID using a factory using the identityOwner address as salt.\n   *  @param identityOwner the address to set as a management key.\n   */\n  function deployIdentityForWallet(address identityOwner) external returns (address) {\n    if (identityOwner == address(0)) {\n      revert ZeroAddress();\n    }\n\n    return idFactory.createIdentity(identityOwner, Strings.toHexString(identityOwner));\n  }\n\n  /**\n   *  @dev Revoke a signature, if the signature is used to deploy an ONCHAINID, the deployment would be rejected.\n   *  @param signature the signature to revoke.\n   */\n  function revokeSignature(bytes calldata signature) external onlyOwner {\n    if (revokedSignatures[signature]) {\n      revert SignatureAlreadyRevoked(signature);\n    }\n\n    revokedSignatures[signature] = true;\n\n    emit SignatureRevoked(signature);\n  }\n\n  /**\n   *  @dev Remove a signature from the revoke list.\n   *  @param signature the signature to approve.\n   */\n  function approveSignature(bytes calldata signature) external onlyOwner {\n    if (!revokedSignatures[signature]) {\n      revert SignatureNotRevoked(signature);\n    }\n\n    delete revokedSignatures[signature];\n\n    emit SignatureApproved(signature);\n  }\n\n  /**\n   *  @dev Transfer the ownership of the factory to a new owner.\n   *  @param newOwner the new owner of the factory.\n   */\n  function transferFactoryOwnership(address newOwner) external onlyOwner {\n    idFactory.transferOwnership(newOwner);\n  }\n\n  /**\n   *  @dev Call a function on the factory. Only the owner of the Gateway can call this method.\n   *  @param data the data to call on the factory.\n   */\n  function callFactory(bytes memory data) external onlyOwner {\n    (bool success, ) = address(idFactory).call(data);\n    require(success, 'Gateway: call to factory failed');\n  }\n}\n"
    },
    "src/IAccessRegistry.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2024 Fireblocks <support@fireblocks.com>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\npragma solidity 0.8.20;\n\n/**\n * @title Access Registry Interface\n * @author Fireblocks\n * @notice Access Registry Interface serves as a generalized interface for interacting with the Access Registry.\n *\n * @dev Interface for the Access Registry features.\n */\ninterface IAccessRegistry {\n  /**\n   * @notice This function is used to check if the account has necessary permissions to access the system.\n   * @param account The account to be checked.\n   * @param caller The account calling the function requiring an access check.\n   * @param data The data associated with the function call\n   * @return true if the account is allowed to access the system (false otherwise).\n   */\n  function hasAccess(address account, address caller, bytes calldata data) external view returns (bool);\n}\n"
    },
    "src/Identity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport './interface/IIdentity.sol';\nimport './interface/IClaimIssuer.sol';\nimport './version/Version.sol';\nimport './storage/Storage.sol';\nimport { CrossChainBridge } from './bridge/Bridge.sol';\n\n/**\n * @dev Implementation of the `IERC734` \"KeyHolder\" and the `IERC735` \"ClaimHolder\" interfaces\n * into a common Identity Contract.\n * This implementation has a separate contract were it declares all storage,\n * allowing for it to be used as an upgradable logic contract.\n */\ncontract Identity is Storage, IIdentity, Version {\n  /**\n   * @notice Prevent any direct calls to the implementation contract (marked by _canInteract = false).\n   */\n  modifier delegatedOnly() {\n    require(_canInteract == true, 'Interacting with the library contract is forbidden.');\n    _;\n  }\n\n  /**\n   * @notice requires management key to call this function, or internal call\n   */\n  modifier onlyManager() {\n    require(\n      msg.sender == address(this) ||\n        msg.sender == idFactory.getBridge() ||\n        keyHasPurpose(keccak256(abi.encode(msg.sender)), 1),\n      'Permissions: Sender does not have management key'\n    );\n    _;\n  }\n\n  /**\n   * @notice requires claim key to call this function, or internal call\n   */\n  modifier onlyClaimKey() {\n    require(\n      msg.sender == address(this) ||\n        msg.sender == idFactory.getBridge() ||\n        keyHasPurpose(keccak256(abi.encode(msg.sender)), 3),\n      'Permissions: Sender does not have claim signer key'\n    );\n    _;\n  }\n\n  /**\n   * @notice constructor of the Identity contract\n   * @param initialManagementKey the address of the management key at deployment\n   * @param _isLibrary boolean value stating if the contract is library or not\n   * calls __Identity_init if contract is not library\n   */\n  constructor(address initialManagementKey, bool _isLibrary, address idFactoryAddress) {\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\n\n    if (!_isLibrary) {\n      __Identity_init(initialManagementKey, idFactoryAddress);\n    } else {\n      _initialized = true;\n    }\n    userWallet = initialManagementKey;\n    idFactory = IdFactory(idFactoryAddress);\n  }\n\n  /**\n   * @notice When using this contract as an implementation for a proxy, call this initializer with a delegatecall.\n   *\n   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n   */\n  function initialize(address initialManagementKey, address _idFactoryAddress) external {\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\n    __Identity_init(initialManagementKey, _idFactoryAddress);\n  }\n\n  /**\n   * @dev See {IERC734-execute}.\n   * @notice Passes an execution instruction to the keymanager.\n   * If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n   * execution is immediately approved and performed.\n   * If the destination address is the identity itself, then the execution would be performed immediately only if\n   * the sender is a MANAGEMENT key.\n   * Otherwise the execution request must be approved via the `approve` method.\n   * @return executionId to use in the approve function, to approve or reject this execution.\n   */\n  function execute(\n    address _to,\n    uint256 _value,\n    bytes memory _data\n  ) external payable override delegatedOnly returns (uint256 executionId) {\n    uint256 _executionId = _executionNonce;\n    _executions[_executionId].to = _to;\n    _executions[_executionId].value = _value;\n    _executions[_executionId].data = _data;\n    _executionNonce++;\n\n    emit ExecutionRequested(_executionId, _to, _value, _data);\n\n    if (keyHasPurpose(keccak256(abi.encode(msg.sender)), 1)) {\n      approve(_executionId, true);\n    } else if (_to != address(this) && keyHasPurpose(keccak256(abi.encode(msg.sender)), 2)) {\n      approve(_executionId, true);\n    }\n\n    return _executionId;\n  }\n\n  /**\n   * @dev See {IERC734-getKey}.\n   * @notice Implementation of the getKey function from the ERC-734 standard\n   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n   * @return purposes Returns the full key data, if present in the identity.\n   * @return keyType Returns the full key data, if present in the identity.\n   * @return key Returns the full key data, if present in the identity.\n   */\n  function getKey(\n    bytes32 _key\n  ) external view override returns (uint256[] memory purposes, uint256 keyType, bytes32 key) {\n    return (_keys[_key].purposes, _keys[_key].keyType, _keys[_key].key);\n  }\n\n  /**\n   * @dev See {IERC734-getKeyPurposes}.\n   * @notice gets the purposes of a key\n   * @param _key The public key.  for non-hex and long keys, its the Keccak256 hash of the key\n   * @return _purposes Returns the purposes of the specified key\n   */\n  function getKeyPurposes(bytes32 _key) external view override returns (uint256[] memory _purposes) {\n    return (_keys[_key].purposes);\n  }\n\n  /**\n   * @dev See {IERC734-getKeysByPurpose}.\n   * @notice gets all the keys with a specific purpose from an identity\n   * @param _purpose a uint256[] Array of the key types, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n   * @return keys Returns an array of public key bytes32 hold by this identity and having the specified purpose\n   */\n  function getKeysByPurpose(uint256 _purpose) external view override returns (bytes32[] memory keys) {\n    return _keysByPurpose[_purpose];\n  }\n\n  /**\n   * @dev See {IERC735-getClaimIdsByTopic}.\n   * @notice Implementation of the getClaimIdsByTopic function from the ERC-735 standard.\n   * used to get all the claims from the specified topic\n   * @param _topic The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n   * @return claimIds Returns an array of claim IDs by topic.\n   */\n  function getClaimIdsByTopic(uint256 _topic) external view override returns (bytes32[] memory claimIds) {\n    return _claimsByTopic[_topic];\n  }\n\n  function isComingFromIdentity(bool done) public returns (bool) {\n    if (msg.sender == address(idFactory) && done == false) {\n      isComing = false;\n    }\n    return isComing;\n  }\n\n  /**\n   * @notice implementation of the addKey function of the ERC-734 standard\n   * Adds a _key to the identity. The _purpose specifies the purpose of key. Initially we propose four purposes:\n   * 1: MANAGEMENT keys, which can manage the identity\n   * 2: ACTION keys, which perform actions in this identities name (signing, logins, transactions, etc.)\n   * 3: CLAIM signer keys, used to sign claims on other identities which need to be revokable.\n   * 4: ENCRYPTION keys, used to encrypt data e.g. hold in claims.\n   * MUST only be done by keys of purpose 1, or the identity itself.\n   * If its the identity itself, the approval process will determine its approval.\n   * @param _key keccak256 representation of an ethereum address\n   * @param _type type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n   * @param _purpose a uint256 specifying the key type, like 1 = MANAGEMENT, 2 = ACTION, 3 = CLAIM, 4 = ENCRYPTION\n   * @return success Returns TRUE if the addition was successful and FALSE if not\n   */\n  function addKey(\n    bytes32 _key,\n    uint256 _purpose,\n    uint256 _type\n  ) public override delegatedOnly onlyManager returns (bool success) {\n    if (_keys[_key].key == _key) {\n      uint256[] memory _purposes = _keys[_key].purposes;\n      for (uint keyPurposeIndex = 0; keyPurposeIndex < _purposes.length; keyPurposeIndex++) {\n        uint256 purpose = _purposes[keyPurposeIndex];\n\n        if (purpose == _purpose) {\n          revert('Conflict: Key already has purpose');\n        }\n      }\n\n      _keys[_key].purposes.push(_purpose);\n    } else {\n      _keys[_key].key = _key;\n      _keys[_key].purposes = [_purpose];\n      _keys[_key].keyType = _type;\n    }\n\n    _keysByPurpose[_purpose].push(_key);\n    \n    emit KeyAdded(_key, _purpose, _type);\n\n    // So OZ Defender doesn't initiate stellar transactions when creating Identity With Management Keys\n    if (msg.sender != address(idFactory)) {      \n      isComing = true;\n      idFactory.addedKey(\n      isComing,\n      _key,\n      _purpose,\n      _type\n      );\n    }\n\n    bool isHomeChain = idFactory._isHomeChain();\n    // Don't send message when calling via createIdentityWithManagementKeys\n    if (isHomeChain && msg.sender != address(idFactory)) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors and their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n        bridge.sendAddKey(chainSelectors[i], receivers[i], _key, _purpose, _type);\n      }\n    } else {}\n\n    return true;\n  }\n\n  /**\n   *  @dev See {IERC734-approve}.\n   *  @notice Approves an execution.\n   *  If the sender is an ACTION key and the destination address is not the identity contract itself, then the\n   *  approval is authorized and the operation would be performed.\n   *  If the destination address is the identity itself, then the execution would be authorized and performed only\n   *  if the sender is a MANAGEMENT key.\n   */\n  function approve(uint256 _id, bool _approve) public override delegatedOnly returns (bool success) {\n    require(_id < _executionNonce, 'Cannot approve a non-existing execution');\n    require(!_executions[_id].executed, 'Request already executed');\n\n    if (_executions[_id].to == address(this)) {\n      require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 1), 'Sender does not have management key');\n    } else {\n      require(keyHasPurpose(keccak256(abi.encode(msg.sender)), 2), 'Sender does not have action key');\n    }\n\n    emit Approved(_id, _approve);\n\n    if (_approve == true) {\n      _executions[_id].approved = true;\n\n      // solhint-disable-next-line avoid-low-level-calls\n      (success, ) = _executions[_id].to.call{ value: (_executions[_id].value) }(_executions[_id].data);\n\n      if (success) {\n        _executions[_id].executed = true;\n\n        emit Executed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n        return true;\n      } else {\n        emit ExecutionFailed(_id, _executions[_id].to, _executions[_id].value, _executions[_id].data);\n\n        return false;\n      }\n    } else {\n      _executions[_id].approved = false;\n    }\n    return false;\n  }\n\n  /**\n   * @dev See {IERC734-removeKey}.\n   * @notice Remove the purpose from a key.\n   */\n  function removeKey(bytes32 _key, uint256 _purpose) public override delegatedOnly onlyManager returns (bool success) {\n    require(_keys[_key].key == _key, \"NonExisting: Key isn't registered\");\n    uint256[] memory _purposes = _keys[_key].purposes;\n\n    uint purposeIndex = 0;\n    while (_purposes[purposeIndex] != _purpose) {\n      purposeIndex++;\n\n      if (purposeIndex == _purposes.length) {\n        revert(\"NonExisting: Key doesn't have such purpose\");\n      }\n    }\n\n    _purposes[purposeIndex] = _purposes[_purposes.length - 1];\n    _keys[_key].purposes = _purposes;\n    _keys[_key].purposes.pop();\n\n    uint keyIndex = 0;\n    uint arrayLength = _keysByPurpose[_purpose].length;\n\n    while (_keysByPurpose[_purpose][keyIndex] != _key) {\n      keyIndex++;\n\n      if (keyIndex >= arrayLength) {\n        break;\n      }\n    }\n\n    _keysByPurpose[_purpose][keyIndex] = _keysByPurpose[_purpose][arrayLength - 1];\n    _keysByPurpose[_purpose].pop();\n\n    uint keyType = _keys[_key].keyType;\n\n    if (_purposes.length - 1 == 0) {\n      delete _keys[_key];\n    }\n\n    emit KeyRemoved(_key, _purpose, keyType);\n\n    // So OZ Defender doesn't initiate stellar transactions when creating Identity With Management Keys\n    if (msg.sender != address(idFactory)) {      \n      isComing = true;\n      idFactory.removedKey(\n      isComing,\n      _key,\n      _purpose,\n      keyType\n      );\n    }\n\n    bool isHomeChain = idFactory._isHomeChain();\n    // Don't send message when calling via createIdentityWithManagementKeys\n    if (isHomeChain && msg.sender != address(idFactory)) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors and their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n        bridge.sendRemoveKey(chainSelectors[i], receivers[i], _key, _purpose);    \n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev See {IERC735-addClaim}.\n   * @notice Implementation of the addClaim function from the ERC-735 standard\n   *  Require that the msg.sender has claim signer key.\n   *\n   * @param _topic The type of claim\n   * @param _scheme The scheme with which this claim SHOULD be verified or how it should be processed.\n   * @param _issuer The issuers identity contract address, or the address used to sign the above signature.\n   * @param _signature Signature which is the proof that the claim issuer issued a claim of topic for this identity.\n   * it MUST be a signed message of the following structure:\n   * keccak256(abi.encode(address identityHolder_address, uint256 _ topic, bytes data))\n   * @param _data The hash of the claim data, sitting in another\n   * location, a bit-mask, call data, or actual data based on the claim scheme.\n   * @param _uri The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n   *\n   * @return claimRequestId Returns claimRequestId: COULD be\n   * send to the approve function, to approve or reject this claim.\n   * triggers ClaimAdded event.\n   */\n  function addClaim(\n    uint256 _topic,\n    uint256 _scheme,\n    address _issuer,\n    bytes memory _signature,\n    bytes memory _data,\n    string memory _uri\n  ) public override delegatedOnly onlyClaimKey returns (bytes32 claimRequestId) {\n    if (_issuer != address(this)) {\n      require(IClaimIssuer(_issuer).isClaimValid(IIdentity(address(this)), _topic, _signature, _data), 'invalid claim');\n    }\n\n    bytes32 claimId = keccak256(abi.encode(_issuer, _topic));\n    _claims[claimId].topic = _topic;\n    _claims[claimId].scheme = _scheme;\n    _claims[claimId].signature = _signature;\n    _claims[claimId].data = _data;\n    _claims[claimId].uri = _uri;\n\n    if (_claims[claimId].issuer != _issuer) {\n      _claimsByTopic[_topic].push(claimId);\n      _claims[claimId].issuer = _issuer;\n\n      // Call Factory, Get Bridge\n      // Call Bridge, Send Claim\n\n      emit ClaimAdded(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n    } else {\n      emit ClaimChanged(claimId, _topic, _scheme, _issuer, _signature, _data, _uri);\n    }\n    isComing = true;\n    idFactory.addedClaim(isComing, _topic, _scheme, _issuer, _signature, _data, _uri);\n\n    bool isHomeChain = idFactory._isHomeChain();\n    if (isHomeChain) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors andand their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n          bridge.sendAddClaim(\n            chainSelectors[i],\n            receivers[i],\n            _topic,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n          );\n        }\n      }\n\n    return claimId;\n  }\n\n  /**\n   * @dev See {IERC735-removeClaim}.\n   * @notice Implementation of the removeClaim function from the ERC-735 standard\n   * Require that the msg.sender has management key.\n   * Can only be removed by the claim issuer, or the claim holder itself.\n   *\n   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n   *\n   * @return success Returns TRUE when the claim was removed.\n   * triggers ClaimRemoved event\n   */\n  function removeClaim(bytes32 _claimId) public override delegatedOnly onlyClaimKey returns (bool success) {\n    uint256 _topic = _claims[_claimId].topic;\n    if (_topic == 0) {\n      revert('NonExisting: There is no claim with this ID');\n    }\n\n    uint claimIndex = 0;\n    uint arrayLength = _claimsByTopic[_topic].length;\n    while (_claimsByTopic[_topic][claimIndex] != _claimId) {\n      claimIndex++;\n\n      if (claimIndex >= arrayLength) {\n        break;\n      }\n    }\n\n    _claimsByTopic[_topic][claimIndex] = _claimsByTopic[_topic][arrayLength - 1];\n    _claimsByTopic[_topic].pop();\n\n    emit ClaimRemoved(\n      _claimId,\n      _topic,\n      _claims[_claimId].scheme,\n      _claims[_claimId].issuer,\n      _claims[_claimId].signature,\n      _claims[_claimId].data,\n      _claims[_claimId].uri\n    );\n\n    delete _claims[_claimId];\n\n    isComing = true;\n    idFactory.removedClaim(\n      isComing,\n      _claimId,\n      _topic,\n      _claims[_claimId].scheme,\n      _claims[_claimId].issuer,\n      _claims[_claimId].signature,\n      _claims[_claimId].data,\n      _claims[_claimId].uri\n    );\n\n    bool isHomeChain = idFactory._isHomeChain();\n    if (isHomeChain) {\n      address bridgeAddress = idFactory.getBridge();\n      // Explicit conversion to payable address and then to CrossChainBridge\n      CrossChainBridge bridge = CrossChainBridge(payable(bridgeAddress));\n\n      // Get Destination Chain Selectors and their receivers\n      address[] memory receivers = idFactory.getReceivers();\n      uint64[] memory chainSelectors = idFactory.getChainSelectors();\n\n      // Send message to the bridge\n      for (uint i = 0; i < receivers.length; i++) {\n        bridge.sendRemoveClaim(chainSelectors[i], receivers[i], _claimId);\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev See {IERC735-getClaim}.\n   * @notice Implementation of the getClaim function from the ERC-735 standard.\n   *\n   * @param _claimId The identity of the claim i.e. keccak256(abi.encode(_issuer, _topic))\n   *\n   * @return topic Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return scheme Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return issuer Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return signature Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return data Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   * @return uri Returns all the parameters of the claim for the\n   * specified _claimId (topic, scheme, signature, issuer, data, uri) .\n   */\n  function getClaim(\n    bytes32 _claimId\n  )\n    public\n    view\n    override\n    returns (\n      uint256 topic,\n      uint256 scheme,\n      address issuer,\n      bytes memory signature,\n      bytes memory data,\n      string memory uri\n    )\n  {\n    return (\n      _claims[_claimId].topic,\n      _claims[_claimId].scheme,\n      _claims[_claimId].issuer,\n      _claims[_claimId].signature,\n      _claims[_claimId].data,\n      _claims[_claimId].uri\n    );\n  }\n\n  /**\n   * @dev See {IERC734-keyHasPurpose}.\n   * @notice Returns true if the key has MANAGEMENT purpose or the specified purpose.\n   */\n  function keyHasPurpose(bytes32 _key, uint256 _purpose) public view override returns (bool result) {\n    Key memory key = _keys[_key];\n    if (key.key == 0) return false;\n\n    for (uint keyPurposeIndex = 0; keyPurposeIndex < key.purposes.length; keyPurposeIndex++) {\n      uint256 purpose = key.purposes[keyPurposeIndex];\n\n      if (purpose == 1 || purpose == _purpose) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @dev Checks if a claim is valid. Claims issued by the identity are self-attested claims. They do not have a\n   * built-in revocation mechanism and are considered valid as long as their signature is valid and they are still\n   * stored by the identity contract.\n   * @param _identity the identity contract related to the claim\n   * @param claimTopic the claim topic of the claim\n   * @param sig the signature of the claim\n   * @param data the data field of the claim\n   * @return claimValid true if the claim is valid, false otherwise\n   */\n  function isClaimValid(\n    IIdentity _identity,\n    uint256 claimTopic,\n    bytes memory sig,\n    bytes memory data\n  ) public view virtual override returns (bool claimValid) {\n    bytes32 dataHash = keccak256(abi.encode(_identity, claimTopic, data));\n    // Use abi.encodePacked to concatenate the message prefix and the message to sign.\n    bytes32 prefixedHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n32', dataHash));\n\n    // Recover address of data signer\n    address recovered = getRecoveredAddress(sig, prefixedHash);\n\n    // Take hash of recovered address\n    bytes32 hashedAddr = keccak256(abi.encode(recovered));\n\n    // Does the trusted identifier have they key which signed the user's claim?\n    //  && (isClaimRevoked(_claimId) == false)\n    if (keyHasPurpose(hashedAddr, 3)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * @dev returns the address that signed the given data\n   * @param sig the signature of the data\n   * @param dataHash the data that was signed\n   * returns the address that signed dataHash and created the signature sig\n   */\n  function getRecoveredAddress(bytes memory sig, bytes32 dataHash) public pure returns (address addr) {\n    bytes32 ra;\n    bytes32 sa;\n    uint8 va;\n\n    // Check the signature length\n    if (sig.length != 65) {\n      return address(0);\n    }\n\n    // Divide the signature in r, s and v variables\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      ra := mload(add(sig, 32))\n      sa := mload(add(sig, 64))\n      va := byte(0, mload(add(sig, 96)))\n    }\n\n    if (va < 27) {\n      va += 27;\n    }\n\n    address recoveredAddress = ecrecover(dataHash, va, ra, sa);\n\n    return (recoveredAddress);\n  }\n\n  /**\n   * @notice Initializer internal function for the Identity contract.\n   *\n   * @param initialManagementKey The ethereum address to be set as the management key of the ONCHAINID.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function __Identity_init(address initialManagementKey, address _idFactoryAddress) internal {\n    require(!_initialized || _isConstructor(), 'Initial key was already setup.');\n    _initialized = true;\n    _canInteract = true;\n    \n    userWallet = initialManagementKey;\n    idFactory = IdFactory(_idFactoryAddress);\n\n    bytes32 _key = keccak256(abi.encode(initialManagementKey));\n    _keys[_key].key = _key;\n    _keys[_key].purposes = [1];\n    _keys[_key].keyType = 1;\n    _keysByPurpose[1].push(_key);\n    emit KeyAdded(_key, 1, 1);\n  }\n\n  /**\n   * @notice Computes if the context in which the function is called is a constructor or not.\n   *\n   * @return true if the context is a constructor.\n   */\n  function _isConstructor() private view returns (bool) {\n    address self = address(this);\n    uint256 cs;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      cs := extcodesize(self)\n    }\n    return cs == 0;\n  }\n}\n"
    },
    "src/interface/IClaimIssuer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"./IIdentity.sol\";\n\ninterface IClaimIssuer is IIdentity {\n\t/**\n\t * @dev Emitted when a claim is revoked.\n\t *\n\t * Specification: MUST be triggered when revoking a claim.\n\t */\n\tevent ClaimRevoked(bytes indexed signature);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @notice will fetch the claim from the identity contract (unsafe).\n\t * @param _claimId the id of the claim\n\t * @param _identity the address of the identity contract\n\t * @return isRevoked true when the claim is revoked\n\t */\n\tfunction revokeClaim(bytes32 _claimId, address _identity) external returns (bool);\n\n\t/**\n\t * @dev Revoke a claim previously issued, the claim is no longer considered as valid after revocation.\n\t * @param signature the signature of the claim\n\t */\n\tfunction revokeClaimBySignature(bytes calldata signature) external;\n\n\t/**\n\t * @dev Returns revocation status of a claim.\n\t * @param _sig the signature of the claim\n\t * @return isRevoked true if the claim is revoked and false otherwise\n\t */\n\tfunction isClaimRevoked(bytes calldata _sig) external view returns (bool);\n\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IERC734.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\n/**\n * @dev interface of the ERC734 (Key Holder) standard as defined in the EIP.\n */\ninterface IERC734 {\n\t/**\n\t * @dev Emitted when an execution request was approved.\n\t *\n\t * Specification: MUST be triggered when approve was successfully called.\n\t */\n\tevent Approved(uint256 indexed executionId, bool approved);\n\n\t/**\n\t * @dev Emitted when an execute operation was approved and successfully performed.\n\t *\n\t * Specification: MUST be triggered when approve was called and the execution was successfully approved.\n\t */\n\tevent Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execution request was performed via `execute`.\n\t *\n\t * Specification: MUST be triggered when execute was successfully called.\n\t */\n\tevent ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when an execute operation was called and failed\n\t *\n\t * Specification: MUST be triggered when execute call failed\n\t */\n\tevent ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n\n\t/**\n\t * @dev Emitted when a key was added to the Identity.\n\t *\n\t * Specification: MUST be triggered when addKey was successfully called.\n\t */\n\tevent KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\t/**\n\t * @dev Emitted when a key was removed from the Identity.\n\t *\n\t * Specification: MUST be triggered when removeKey was successfully called.\n\t */\n\tevent KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n\n\n\t/**\n\t * \n\t * @dev Returns True if call is coming from Identity Contract\n\t */\n\tfunction isComingFromIdentity(bool done) external returns (bool);\n\t\n\t/**\n\t * @dev Adds a _key to the identity. The _purpose specifies the purpose of the key.\n\t *\n\t * Triggers Event: `KeyAdded`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity\n\t * itself. If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) external returns (bool success);\n\n\t/**\n\t * @dev Approves an execution.\n\t *\n\t * Triggers Event: `Approved`\n\t * Triggers on execution successful Event: `Executed`\n\t * Triggers on execution failure Event: `ExecutionFailed`\n\t */\n\tfunction approve(uint256 _id, bool _approve) external returns (bool success);\n\n\t/**\n\t * @dev Removes _purpose for _key from the identity.\n\t *\n\t * Triggers Event: `KeyRemoved`\n\t *\n\t * Specification: MUST only be done by keys of purpose 1, or the identity itself.\n\t * If it's the identity itself, the approval process will determine its approval.\n\t */\n\tfunction removeKey(bytes32 _key, uint256 _purpose) external returns (bool success);\n\n\t/**\n\t * @dev Passes an execution instruction to an ERC734 identity.\n\t * How the execution is handled is up to the identity implementation:\n\t * An execution COULD be requested and require `approve` to be called with one or more keys of purpose 1 or 2 to\n\t * approve this execution.\n\t * Execute COULD be used as the only accessor for `addKey` and `removeKey`.\n\t *\n\t * Triggers Event: ExecutionRequested\n\t * Triggers on direct execution Event: Executed\n\t */\n\tfunction execute(address _to, uint256 _value, bytes calldata _data) external payable returns (uint256 executionId);\n\n\t/**\n\t * @dev Returns the full key data, if present in the identity.\n\t */\n\tfunction getKey(bytes32 _key) external view returns (uint256[] memory purposes, uint256 keyType, bytes32 key);\n\n\t/**\n\t * @dev Returns the list of purposes associated with a key.\n\t */\n\tfunction getKeyPurposes(bytes32 _key) external view returns (uint256[] memory _purposes);\n\n\t/**\n\t * @dev Returns an array of public key bytes32 held by this identity.\n\t */\n\tfunction getKeysByPurpose(uint256 _purpose) external view returns (bytes32[] memory keys);\n\n\t/**\n\t * @dev Returns TRUE if a key is present and has the given purpose. If the key is not present it returns FALSE.\n\t */\n\tfunction keyHasPurpose(bytes32 _key, uint256 _purpose) external view returns (bool exists);\n}\n"
    },
    "src/interface/IERC735.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\n/**\n * @dev interface of the ERC735 (Claim Holder) standard as defined in the EIP.\n */\ninterface IERC735 {\n\t/**\n\t * @dev Emitted when a claim was added.\n\t *\n\t * Specification: MUST be triggered when a claim was successfully added.\n\t */\n\tevent ClaimAdded(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was removed.\n\t *\n\t * Specification: MUST be triggered when removeClaim was successfully called.\n\t */\n\tevent ClaimRemoved(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Emitted when a claim was changed.\n\t *\n\t * Specification: MUST be triggered when addClaim was successfully called on an existing claimId.\n\t */\n\tevent ClaimChanged(\n\t\tbytes32 indexed claimId,\n\t\tuint256 indexed topic,\n\t\tuint256 scheme,\n\t\taddress indexed issuer,\n\t\tbytes signature,\n\t\tbytes data,\n\t\tstring uri\n\t);\n\n\t/**\n\t * @dev Add or update a claim.\n\t *\n\t * Triggers Event: `ClaimAdded`, `ClaimChanged`\n\t *\n\t * Specification: Add or update a claim from an issuer.\n\t *\n\t * _signature is a signed message of the following structure:\n\t * `keccak256(abi.encode(address identityHolder_address, uint256 topic, bytes data))`.\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address + uint256 topic))`.\n\t */\n\tfunction addClaim(\n\t\tuint256 _topic,\n\t\tuint256 _scheme,\n\t\taddress issuer,\n\t\tbytes calldata _signature,\n\t\tbytes calldata _data,\n\t\tstring calldata _uri\n\t) external returns (bytes32 claimRequestId);\n\n\t/**\n\t * @dev Removes a claim.\n\t *\n\t * Triggers Event: `ClaimRemoved`\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction removeClaim(bytes32 _claimId) external returns (bool success);\n\n\t/**\n\t * @dev Get a claim by its ID.\n\t *\n\t * Claim IDs are generated using `keccak256(abi.encode(address issuer_address, uint256 topic))`.\n\t */\n\tfunction getClaim(\n\t\tbytes32 _claimId\n\t)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\tuint256 topic,\n\t\t\tuint256 scheme,\n\t\t\taddress issuer,\n\t\t\tbytes memory signature,\n\t\t\tbytes memory data,\n\t\t\tstring memory uri\n\t\t);\n\n\t/**\n\t * @dev Returns an array of claim IDs by topic.\n\t */\n\tfunction getClaimIdsByTopic(uint256 _topic) external view returns (bytes32[] memory claimIds);\n}\n"
    },
    "src/interface/IIdentity.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\nimport \"./IERC734.sol\";\nimport \"./IERC735.sol\";\n\n// solhint-disable-next-line no-empty-blocks\ninterface IIdentity is IERC734, IERC735 {\n\t/**\n\t * @dev Checks if a claim is valid.\n\t * @param _identity the identity contract related to the claim\n\t * @param claimTopic the claim topic of the claim\n\t * @param sig the signature of the claim\n\t * @param data the data field of the claim\n\t * @return claimValid true if the claim is valid, false otherwise\n\t */\n\tfunction isClaimValid(\n\t\tIIdentity _identity,\n\t\tuint256 claimTopic,\n\t\tbytes calldata sig,\n\t\tbytes calldata data\n\t) external view returns (bool);\n}\n"
    },
    "src/interface/IImplementationAuthority.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.20;\n\ninterface IImplementationAuthority {\n\t// event emitted when the implementation contract is updated\n\tevent UpdatedImplementation(address newAddress);\n\n\t/**\n\t * @dev updates the address used as implementation by the proxies linked\n\t * to this ImplementationAuthority contract\n\t * @param _newImplementation the address of the new implementation contract\n\t * only Owner can call\n\t */\n\tfunction updateImplementation(address _newImplementation) external;\n\n\t/**\n\t * @dev returns the address of the implementation\n\t */\n\tfunction getImplementation() external view returns (address);\n}\n"
    },
    "src/proxy/IdentityProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.20;\n\nimport '../interface/IImplementationAuthority.sol';\n\ncontract IdentityProxy {\n  /**\n   *  @dev constructor of the proxy Identity contract\n   *  @param _implementationAuthority the implementation Authority contract address\n   *  @param initialManagementKey the management key at deployment\n   *  @param _idFactoryAddress the _idFactoryAddress at deployment\n   *  the proxy is going to use the logic deployed on the implementation contract\n   *  deployed at an address listed in the ImplementationAuthority contract\n   */\n  constructor(address _implementationAuthority, address initialManagementKey, address _idFactoryAddress) {\n    require(_implementationAuthority != address(0), 'invalid argument - zero address');\n    require(initialManagementKey != address(0), 'invalid argument - zero address');\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc, _implementationAuthority)\n    }\n\n    address logic = IImplementationAuthority(_implementationAuthority).getImplementation();\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success, ) = logic.delegatecall(\n      abi.encodeWithSignature('initialize(address,address)', initialManagementKey, _idFactoryAddress)\n    );\n    require(success, 'Initialization failed.');\n  }\n\n  /**\n   *  @dev fallback proxy function used for any transaction call that is made using\n   *  the Identity contract ABI and called on the proxy contract\n   *  The proxy will update its local storage depending on the behaviour requested\n   *  by the implementation contract given by the Implementation Authority\n   */\n  // solhint-disable-next-line no-complex-fallback\n  fallback() external payable {\n    address logic = IImplementationAuthority(implementationAuthority()).getImplementation();\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      calldatacopy(0x0, 0x0, calldatasize())\n      let success := delegatecall(sub(gas(), 10000), logic, 0x0, calldatasize(), 0, 0)\n      let retSz := returndatasize()\n      returndatacopy(0, 0, retSz)\n      switch success\n      case 0 {\n        revert(0, retSz)\n      }\n      default {\n        return(0, retSz)\n      }\n    }\n  }\n\n  function implementationAuthority() public view returns (address) {\n    address implemAuth;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      implemAuth := sload(0x821f3e4d3d679f19eacc940c87acf846ea6eae24a63058ea750304437a62aafc)\n    }\n    return implemAuth;\n  }\n}\n"
    },
    "src/proxy/ImplementationAuthority.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.20;\n\nimport '../interface/IImplementationAuthority.sol';\nimport '@openzeppelin/contracts/access/Ownable.sol';\n\ncontract ImplementationAuthority is IImplementationAuthority, Ownable {\n  // the address of implementation of ONCHAINID\n  address internal _implementation;\n\n  constructor() {}\n\n  /**\n   *  @dev See {IImplementationAuthority-updateImplementation}.\n   */\n  function updateImplementation(address _newImplementation) external override onlyOwner {\n    require(_newImplementation != address(0), 'invalid argument - zero address');\n    _implementation = _newImplementation;\n    emit UpdatedImplementation(_newImplementation);\n  }\n\n  /**\n   *  @dev See {IImplementationAuthority-getImplementation}.\n   */\n  function getImplementation() external view override returns (address) {\n    return _implementation;\n  }\n}\n"
    },
    "src/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\nimport \"./Structs.sol\";\nimport {IdFactory} from \"../factory/IdFactory.sol\";\n\ncontract Storage is Structs {\n\t// factory address\n\tIdFactory public idFactory;\n\n\taddress internal userWallet;\n\n\tbool internal isComing;\n\n\t// nonce used by the execute/approve function\n\tuint256 internal _executionNonce;\n\n\t// keys as defined by IERC734\n\tmapping(bytes32 => Key) internal _keys;\n\n\t// keys for a given purpose\n\t// purpose 1 = MANAGEMENT\n\t// purpose 2 = ACTION\n\t// purpose 3 = CLAIM\n\tmapping(uint256 => bytes32[]) internal _keysByPurpose;\n\n\t// execution data\n\tmapping(uint256 => Execution) internal _executions;\n\n\t// claims held by the ONCHAINID\n\tmapping(bytes32 => Claim) internal _claims;\n\n\t// array of claims for a given topic\n\tmapping(uint256 => bytes32[]) internal _claimsByTopic;\n\n\t// status on initialization\n\tbool internal _initialized = false;\n\n\t// status on potential interactions with the contract\n\tbool internal _canInteract = false;\n\n\t/**\n\t * @dev This empty reserved space is put in place to allow future versions to add new\n\t * variables without shifting down storage in the inheritance chain.\n\t */\n\tuint256[49] private __gap;\n}\n"
    },
    "src/storage/Structs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\ncontract Structs {\n\t/**\n\t *  @dev Definition of the structure of a Key.\n\t *\n\t *  Specification: Keys are cryptographic public keys, or contract addresses associated with this identity.\n\t *  The structure should be as follows:\n\t *  key: A public key owned by this identity\n\t *  purposes: uint256[] Array of the key purposes, like 1 = MANAGEMENT, 2 = EXECUTION\n\t *  keyType: The type of key used, which would be a uint256 for different key types. e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  key: bytes32 The public key. // Its the Keccak256 hash of the key\n\t */\n\tstruct Key {\n\t\tuint256[] purposes;\n\t\tuint256 keyType;\n\t\tbytes32 key;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of an Execution\n\t *\n\t *  Specification: Executions are requests for transactions to be issued by the ONCHAINID\n\t *  to: address of contract to interact with, can be address(this)\n\t *  value: ETH to transfer with the transaction\n\t *  data: payload of the transaction to execute\n\t *  approved: approval status of the Execution\n\t *  executed: execution status of the Execution (set as false when the Execution is created\n\t *  and updated to true when the Execution is processed)\n\t */\n\tstruct Execution {\n\t\taddress to;\n\t\tuint256 value;\n\t\tbytes data;\n\t\tbool approved;\n\t\tbool executed;\n\t}\n\n\t/**\n\t *  @dev Definition of the structure of a Claim.\n\t *\n\t *  Specification: Claims are information an issuer has about the identity holder.\n\t *  The structure should be as follows:\n\t *  claim: A claim published for the Identity.\n\t *  topic: A uint256 number which represents the topic of the claim. (e.g. 1 biometric, 2 residence (ToBeDefined:\n\t *  number schemes, sub topics based on number ranges??))\n\t *  scheme : The scheme with which this claim SHOULD be verified or how it should be processed. Its a uint256 for\n\t *  different schemes. E.g. could 3 mean contract verification, where the data will be call data, and the issuer a\n\t *  contract address to call (ToBeDefined). Those can also mean different key types e.g. 1 = ECDSA, 2 = RSA, etc.\n\t *  (ToBeDefined)\n\t *  issuer: The issuers identity contract address, or the address used to sign the above signature. If an\n\t *  identity contract, it should hold the key with which the above message was signed, if the key is not present\n\t *  anymore, the claim SHOULD be treated as invalid. The issuer can also be a contract address itself, at which the\n\t *  claim can be verified using the call data.\n\t *  signature: Signature which is the proof that the claim issuer issued a claim of topic for this identity. it\n\t *  MUST be a signed message of the following structure: `keccak256(abi.encode(identityHolder_address, topic, data))`\n\t *  data: The hash of the claim data, sitting in another location, a bit-mask, call data, or actual data based on\n\t *  the claim scheme.\n\t *  uri: The location of the claim, this can be HTTP links, swarm hashes, IPFS hashes, and such.\n\t */\n\tstruct Claim {\n\t\tuint256 topic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes signature;\n\t\tbytes data;\n\t\tstring uri;\n\t}\n}\n"
    },
    "src/Test.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.20;\n\ncontract Test {\n\n} // solhint-disable-line\n"
    },
    "src/verifiers/Verifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.20;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interface/IClaimIssuer.sol\";\n\ncontract Verifier is Ownable {\n\t/// @dev All topics of claims required to pass verification.\n\tuint256[] public requiredClaimTopics;\n\n\t/// @dev Array containing all TrustedIssuers identity contract address allowed to issue claims required.\n\tIClaimIssuer[] public trustedIssuers;\n\n\t/// @dev Mapping between a trusted issuer address and the topics of claims they are trusted for.\n\tmapping(address => uint256[]) public trustedIssuerClaimTopics;\n\n\t/// @dev Mapping between a claim topic and the trusted issuers trusted for it.\n\tmapping(uint256 => IClaimIssuer[]) public claimTopicsToTrustedIssuers;\n\n\t/**\n\t *  this event is emitted when a claim topic has been added to the requirement list\n\t *  the event is emitted by the 'addClaimTopic' function\n\t *  `claimTopic` is the required claim topic added\n\t */\n\tevent ClaimTopicAdded(uint256 indexed claimTopic);\n\n\t/**\n\t *  this event is emitted when a claim topic has been removed from the requirement list\n\t *  the event is emitted by the 'removeClaimTopic' function\n\t *  `claimTopic` is the required claim removed\n\t */\n\tevent ClaimTopicRemoved(uint256 indexed claimTopic);\n\n\t/**\n\t *  this event is emitted when an issuer is added to the trusted list.\n\t *  the event is emitted by the addTrustedIssuer function\n\t *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\n\t *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\n\t */\n\tevent TrustedIssuerAdded(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\n\n\t/**\n\t *  this event is emitted when an issuer is removed from the trusted list.\n\t *  the event is emitted by the removeTrustedIssuer function\n\t *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\n\t */\n\tevent TrustedIssuerRemoved(IClaimIssuer indexed trustedIssuer);\n\n\t/**\n\t *  this event is emitted when the set of claim topics is changed for a given trusted issuer.\n\t *  the event is emitted by the updateIssuerClaimTopics function\n\t *  `trustedIssuer` is the address of the trusted issuer's ClaimIssuer contract\n\t *  `claimTopics` is the set of claims that the trusted issuer is allowed to emit\n\t */\n\tevent ClaimTopicsUpdated(IClaimIssuer indexed trustedIssuer, uint256[] claimTopics);\n\n\tmodifier onlyVerifiedSender() {\n\t\trequire(verify(_msgSender()), \"sender is not verified\");\n\t\t_;\n\t}\n\n\t/**\n\t *  @dev See {IClaimTopicsRegistry-removeClaimTopic}.\n\t */\n\tfunction addClaimTopic(uint256 claimTopic) public onlyOwner {\n\t\tuint256 length = requiredClaimTopics.length;\n\t\trequire(length < 15, \"cannot require more than 15 topics\");\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\trequire(requiredClaimTopics[i] != claimTopic, \"claimTopic already exists\");\n\t\t}\n\t\trequiredClaimTopics.push(claimTopic);\n\t\temit ClaimTopicAdded(claimTopic);\n\t}\n\n\t/**\n\t *  @dev See {IClaimTopicsRegistry-getClaimTopics}.\n\t */\n\tfunction removeClaimTopic(uint256 claimTopic) public onlyOwner {\n\t\tuint256 length = requiredClaimTopics.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (requiredClaimTopics[i] == claimTopic) {\n\t\t\t\trequiredClaimTopics[i] = requiredClaimTopics[length - 1];\n\t\t\t\trequiredClaimTopics.pop();\n\t\t\t\temit ClaimTopicRemoved(claimTopic);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-addTrustedIssuer}.\n\t */\n\tfunction addTrustedIssuer(IClaimIssuer trustedIssuer, uint256[] calldata claimTopics) public onlyOwner {\n\t\trequire(address(trustedIssuer) != address(0), \"invalid argument - zero address\");\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length == 0, \"trusted Issuer already exists\");\n\t\trequire(claimTopics.length > 0, \"trusted claim topics cannot be empty\");\n\t\trequire(claimTopics.length <= 15, \"cannot have more than 15 claim topics\");\n\t\trequire(trustedIssuers.length < 50, \"cannot have more than 50 trusted issuers\");\n\t\ttrustedIssuers.push(trustedIssuer);\n\t\ttrustedIssuerClaimTopics[address(trustedIssuer)] = claimTopics;\n\t\tfor (uint256 i = 0; i < claimTopics.length; i++) {\n\t\t\tclaimTopicsToTrustedIssuers[claimTopics[i]].push(trustedIssuer);\n\t\t}\n\t\temit TrustedIssuerAdded(trustedIssuer, claimTopics);\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-removeTrustedIssuer}.\n\t */\n\tfunction removeTrustedIssuer(IClaimIssuer trustedIssuer) public onlyOwner {\n\t\trequire(address(trustedIssuer) != address(0), \"invalid argument - zero address\");\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length != 0, \"NOT a trusted issuer\");\n\t\tuint256 length = trustedIssuers.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (trustedIssuers[i] == trustedIssuer) {\n\t\t\t\ttrustedIssuers[i] = trustedIssuers[length - 1];\n\t\t\t\ttrustedIssuers.pop();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (\n\t\t\tuint256 claimTopicIndex = 0;\n\t\t\tclaimTopicIndex < trustedIssuerClaimTopics[address(trustedIssuer)].length;\n\t\t\tclaimTopicIndex++\n\t\t) {\n\t\t\tuint256 claimTopic = trustedIssuerClaimTopics[address(trustedIssuer)][claimTopicIndex];\n\t\t\tuint256 topicsLength = claimTopicsToTrustedIssuers[claimTopic].length;\n\t\t\tfor (uint256 i = 0; i < topicsLength; i++) {\n\t\t\t\tif (claimTopicsToTrustedIssuers[claimTopic][i] == trustedIssuer) {\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic][i] = claimTopicsToTrustedIssuers[claimTopic][\n\t\t\t\t\t\ttopicsLength - 1\n\t\t\t\t\t];\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic].pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdelete trustedIssuerClaimTopics[address(trustedIssuer)];\n\t\temit TrustedIssuerRemoved(trustedIssuer);\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-updateIssuerClaimTopics}.\n\t */\n\tfunction updateIssuerClaimTopics(IClaimIssuer trustedIssuer, uint256[] calldata newClaimTopics) public onlyOwner {\n\t\trequire(address(trustedIssuer) != address(0), \"invalid argument - zero address\");\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length != 0, \"NOT a trusted issuer\");\n\t\trequire(newClaimTopics.length <= 15, \"cannot have more than 15 claim topics\");\n\t\trequire(newClaimTopics.length > 0, \"claim topics cannot be empty\");\n\n\t\tfor (uint256 i = 0; i < trustedIssuerClaimTopics[address(trustedIssuer)].length; i++) {\n\t\t\tuint256 claimTopic = trustedIssuerClaimTopics[address(trustedIssuer)][i];\n\t\t\tuint256 topicsLength = claimTopicsToTrustedIssuers[claimTopic].length;\n\t\t\tfor (uint256 j = 0; j < topicsLength; j++) {\n\t\t\t\tif (claimTopicsToTrustedIssuers[claimTopic][j] == trustedIssuer) {\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic][j] = claimTopicsToTrustedIssuers[claimTopic][\n\t\t\t\t\t\ttopicsLength - 1\n\t\t\t\t\t];\n\t\t\t\t\tclaimTopicsToTrustedIssuers[claimTopic].pop();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttrustedIssuerClaimTopics[address(trustedIssuer)] = newClaimTopics;\n\t\tfor (uint256 i = 0; i < newClaimTopics.length; i++) {\n\t\t\tclaimTopicsToTrustedIssuers[newClaimTopics[i]].push(trustedIssuer);\n\t\t}\n\t\temit ClaimTopicsUpdated(trustedIssuer, newClaimTopics);\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-getTrustedIssuers}.\n\t */\n\tfunction getTrustedIssuers() public view returns (IClaimIssuer[] memory) {\n\t\treturn trustedIssuers;\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-getTrustedIssuersForClaimTopic}.\n\t */\n\tfunction getTrustedIssuersForClaimTopic(uint256 claimTopic) public view returns (IClaimIssuer[] memory) {\n\t\treturn claimTopicsToTrustedIssuers[claimTopic];\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-isTrustedIssuer}.\n\t */\n\tfunction isTrustedIssuer(address issuer) public view returns (bool) {\n\t\tif (trustedIssuerClaimTopics[issuer].length > 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-getTrustedIssuerClaimTopics}.\n\t */\n\tfunction getTrustedIssuerClaimTopics(IClaimIssuer trustedIssuer) public view returns (uint256[] memory) {\n\t\trequire(trustedIssuerClaimTopics[address(trustedIssuer)].length != 0, \"trusted Issuer doesn't exist\");\n\t\treturn trustedIssuerClaimTopics[address(trustedIssuer)];\n\t}\n\n\t/**\n\t *  @dev See {ITrustedIssuersRegistry-hasClaimTopic}.\n\t */\n\tfunction hasClaimTopic(address issuer, uint256 claimTopic) public view returns (bool) {\n\t\tuint256[] memory claimTopics = trustedIssuerClaimTopics[issuer];\n\t\tuint256 length = claimTopics.length;\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (claimTopics[i] == claimTopic) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction isClaimTopicRequired(uint256 claimTopic) public view returns (bool) {\n\t\tuint256 length = requiredClaimTopics.length;\n\n\t\tfor (uint256 i = 0; i < length; i++) {\n\t\t\tif (requiredClaimTopics[i] == claimTopic) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * @dev Verify an identity (ONCHAINID) by checking if the identity has at least one valid claim from a trusted\n\t * issuer for each required claim topic. Returns true if the identity is compliant, false otherwise.\n\t */\n\tfunction verify(address identity) public view returns (bool isVerified) {\n\t\tif (requiredClaimTopics.length == 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tuint256 foundClaimTopic;\n\t\tuint256 scheme;\n\t\taddress issuer;\n\t\tbytes memory sig;\n\t\tbytes memory data;\n\t\tuint256 claimTopic;\n\t\tfor (claimTopic = 0; claimTopic < requiredClaimTopics.length; claimTopic++) {\n\t\t\tIClaimIssuer[] memory trustedIssuersForClaimTopic = this.getTrustedIssuersForClaimTopic(\n\t\t\t\trequiredClaimTopics[claimTopic]\n\t\t\t);\n\n\t\t\tif (trustedIssuersForClaimTopic.length == 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tbytes32[] memory claimIds = new bytes32[](trustedIssuersForClaimTopic.length);\n\t\t\tfor (uint256 i = 0; i < trustedIssuersForClaimTopic.length; i++) {\n\t\t\t\tclaimIds[i] = keccak256(abi.encode(trustedIssuersForClaimTopic[i], requiredClaimTopics[claimTopic]));\n\t\t\t}\n\n\t\t\tfor (uint256 j = 0; j < claimIds.length; j++) {\n\t\t\t\t(foundClaimTopic, scheme, issuer, sig, data, ) = IIdentity(identity).getClaim(claimIds[j]);\n\n\t\t\t\tif (foundClaimTopic == requiredClaimTopics[claimTopic]) {\n\t\t\t\t\ttry\n\t\t\t\t\t\tIClaimIssuer(issuer).isClaimValid(\n\t\t\t\t\t\t\tIIdentity(identity),\n\t\t\t\t\t\t\trequiredClaimTopics[claimTopic],\n\t\t\t\t\t\t\tsig,\n\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t)\n\t\t\t\t\treturns (bool _validity) {\n\t\t\t\t\t\tif (_validity) {\n\t\t\t\t\t\t\tj = claimIds.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!_validity && j == (claimIds.length - 1)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tif (j == (claimIds.length - 1)) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (j == (claimIds.length - 1)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"
    },
    "src/version/Version.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.20;\n\n/**\n * @dev Version contract gives the versioning information of the implementation contract\n */\ncontract Version {\n\t/**\n\t * @dev Returns the string of the current version.\n\t */\n\tfunction version() external pure returns (string memory) {\n\t\t// version 2.2.0\n\t\treturn \"2.2.1\";\n\t}\n}\n"
    }
  },
  "settings": {
    "viaIR": true,
    "optimizer": {
      "enabled": true,
      "runs": 2000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}